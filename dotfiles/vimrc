" don't load when -eval(vim-tiny, vim-small)
if 0 | endif

" Initialize "{{{
if &compatible | set compatible! | endif

if !exists('g:vimrc#is_starting')
  let g:vimrc#is_windows = has('win32')
  let g:vimrc#is_cygwin = has('win32unix')
  let g:vimrc#is_unix = has('unix') && !g:vimrc#is_cygwin
  let g:vimrc#is_wsl = g:vimrc#is_unix && system('uname -r') =~? 'microsoft'
  let g:vimrc#is_nvim = has('nvim')
  if g:vimrc#is_nvim
    let g:vimrc#is_gui = nvim_list_uis()[0].chan ==# 1
  else
    let g:vimrc#is_gui = has('gui_running')
  endif
  let g:vimrc#is_starting = 1
  let g:vimrc#dotvim = expand('~/.vim')
endif

augroup Vimrc
  autocmd!
  autocmd VimEnter * let g:vimrc#is_starting = 0
augroup END "}}}

" use Vim with singleton "{{{
if has('clientserver') && !exists('g:loaded_editexisting')
  let g:loaded_editexisting = 1
  if has('patch-7.4.1674')
    packadd! editexisting
  else
    runtime macros/editexisting.vim
  endif
endif "}}}

" print startup time "{{{
" https://gist.github.com/thinca/1518874#file-vimrc-L20
if g:vimrc#is_starting && has('reltime')
  let s:startuptime = reltime()
  " :redraw hides intro message
  augroup vimrc-startuptime
    autocmd! VimEnter *
        \ let s:startuptime = reltime(s:startuptime) |
        \ echomsg 'startuptime: ' . reltimestr(s:startuptime) |
        \ unlet s:startuptime | autocmd! vimrc-startuptime
  augroup END
endif "}}}

" encoding "{{{
" if &encoding !=# 'utf-8'
if &term ==# 'win32' " command prompt
  set encoding=cp932
else
  set encoding=utf-8
endif

if g:vimrc#is_windows
  set termencoding=cp932
  setglobal fileencoding=cp932
else
  set termencoding=utf-8
  setglobal fileencoding=utf-8
endif

" setglobal fileencoding=japan
" endif

scriptencoding utf-8 "}}}

" functions "{{{
function! s:mkdir(path) abort "{{{
  " return: ディレクトリを読み込めない(作成できない)とき0, それ以外は1
  if a:path =~# '^.\{-}://' " Non local file, ignore
    return 0
  endif

  for p in split(a:path, ',')
    if !isdirectory(p)
      if !filereadable(p) && !filewritable(p)
        call mkdir(p, 'p')
        return 1
      endif
    else
      return 1
    endif
  endfor

  echoerr a:path . ' should be directory and readable.'
  return 0
endfunction "}}}

" quickfixリストの文字化け回避 "{{{
function! QfMakeConv(fenc, enc) abort
  let qflist = getqflist()
  for i in qflist
    let i.text = iconv(i.text, a:fenc, a:enc)
  endfor
  call setqflist(qflist, 'r')
endfunction "}}}

" 外部スクリプトのローカル関数を呼び出す "{{{
" https://thinca.hatenablog.com/entry/20111228/1325077104
function! CallInternalFunc(f, ...) abort
  let [file, func] = a:f =~# ':' ?  split(a:f, ':') : [expand('%:p'), a:f]
  let fname = matchstr(func, '^\w*')
  let cfunc = ''

  " Get sourced scripts.
  redir => slist
  silent scriptnames
  redir END

  let filepat = '\V' . substitute(file, '\\', '/', 'g') . '\v%(\.vim)?$'
  for s in split(slist, "\n")
    let p = matchlist(s, '^\s*\(\d\+\):\s*\(.*\)$')
    if empty(p)
      continue
    endif
    let [nr, sfile] = p[1 : 2]
    let sfile = fnamemodify(sfile, ':p:gs?\\?/?')
    if sfile =~# filepat && exists(printf("*\<SNR>%d_%s", nr, fname))
      let cfunc = printf("\<SNR>%d_%s", nr, func)
      break
    endif
  endfor

  if !exists('nr')
    echoerr 'Not sourced: ' . file
    return
  elseif !exists('cfunc')
    let file = fnamemodify(file, ':p')
    echoerr printf(
        \ 'File found, but function is not defined: %s: %s()', file, fname)
    return
  endif

  return 0 <= match(func, '^\w*\s*(.*)\s*$')
      \ ? eval(cfunc) : call(cfunc, a:000)
endfunction "}}}

" マップ時のv:countを<Esc>を使わずに削除 "{{{
" ex. noremap <expr> j <SID>delcount(v:count) . 'gj'
function! s:delcount(count) abort
  return !a:count ? '' : repeat("\<Del>", strlen(string(a:count)))
endfunction "}}}

" 自動で生成されるバッファか判定 "{{{
let g:vimrc#generate_filetypes = ['git', 'help', 'netrw', 'qf']

" a:1 - バッファ番号 (0のとき現在のバッファに対して判定)
function! s:ignore(...) abort
  if a:0 && a:1 !=# 0
    let bh = getbufvar(a:1, '&bufhidden')
    let bl = getbufvar(a:1, '&buflisted')
    let bname = fnamemodify(bufname(a:1), ':t')
    let bt = getbufvar(a:1, '&buftype')
    let fts = getbufvar(a:1, '&filetype')
    let wt = exists('*win_gettype') ? win_gettype(bufwinnr(a:1)) : ''
  else
    let bh = &bufhidden
    let bl = &buflisted
    let bname = expand('%:t')
    let bt = &buftype
    let fts = &filetype
    let wt = exists('*win_gettype') ? win_gettype() : ''
  endif

  if !bl
    return 1
  endif

  if !empty(bt)
    return 1
  endif

  if !(bh ==# '' ? &hidden : bh ==# 'hide')
    return 1
  endif

  if !(wt ==# '' || wt ==# 'unknown')
    return 1
  endif

  for ft in split(fts, '\.')
    if index(g:vimrc#generate_filetypes, ft) !=# -1
      return 1
    endif
  endfor

  return bname =~# '^\[Command\ Line\]$'
endfunction "}}}

" 行末の空白をハイライト "{{{
function! HighlightTrailingSpace() abort
  if s:ignore()
    if get(w:, 'spaceid', 0)
      call matchdelete(w:spaceid)
      unlet w:spaceid
    endif
  else
    highlight TrailingWhiteSpace ctermbg=darkred guibg=#ff0000
    if !get(w:, 'spaceid', 0)
      " 行末の空白をハイライト
      let w:spaceid = matchadd('TrailingWhiteSpace', '\s\+$', 11)
    endif
  endif
endfunction "}}}

" 指定範囲の空行を削除 "{{{
function! s:delemptyline(start, last) abort
  " return: 削除した行の数
  let save_cursor = getcurpos()

  let n = 0 | let end = a:last
  call cursor(a:start, 1)
  while 1
    let l = search('^$', 'c', end)
    if l <= 0 | break | endif

    execute l . 'delete' '_'
    let n += 1 | let end -= 1
  endwhile

  call setpos('.', save_cursor)
  return n
endfunction "}}}

" バックスラッシュを消して結合(J) "{{{
function! s:J() range
  set operatorfunc=Concat
  return 'g@' . max([a:lastline - a:firstline - 1, 1]) . 'j'
endfunction

function! Concat(type) abort
  let js_save = &joinspaces
  let sel_save = &selection
  set selection=inclusive

  let startline = line("'[")
  let endline = line("']")

  if startline ==# endline
    let endline += 1
  endif

  let endline -= s:delemptyline(startline, endline)
  if startline < endline
    let lines = getline(startline + 1, endline)

    " ソースコード中では結合時に空白を入れない
    if &filetype !~# '\v(\.|^)text(\.|$)'
      let synname = synIDattr(synID(startline, col('$') - 1, 1), "name")
      if synname !~# '\v(Comment|String)$'
        set nojoinspaces
      else
        " call map(lines, "substitute(v:val, '^\\s*' . substitute(&commentstring, '^\\s*\\|%s', '', 'g'), '', '')")
      endif
    endif

    if &filetype =~# '\v(\.|^)vim(\.|$)'
      " 行継続を削除
      call map(lines, "substitute(v:val, '^\\s*\\\\', '', '')")

      " foldmarkerのコメント文字は残す
      let [foldstart, foldend] = split(&foldmarker, ',')
      call map(lines, printf("substitute(v:val, '\\ze\"\\s*%s', '\" ', '')", foldstart)) " not vim9script
      let lines = [getline(startline)] + lines
    else
      let lastline = lines[-1]
      let lines = [getline(startline)] + lines[:-2]

      " 行継続を削除
      call map(lines, "substitute(v:val, '\\\\$', '', '')")

      let lines += [lastline]
    endif

    call setline(startline, lines)
    execute 'join' endline - startline + 1
  endif

  let &joinspaces = js_save
  let &selection = sel_save
endfunction

noremap <expr> J <SID>J()
noremap <Space>J J
sunmap J
ounmap J
sunmap <Space>J
ounmap <Space>J

nnoremap <silent> <Space><Space>J :<C-u>set operatorfunc=Concat<CR>g@
nnoremap <silent> <Space><Space>JJ :<C-u>set operatorfunc=Concat<CR>g@g@
"}}}

" ウィンドウの左側の余白の幅 "{{{
function! s:winleftpad() abort
  if g:vimrc#is_nvim || has('patch-8.2.3627')
    return getwininfo(win_getid())[0]['textoff']
  endif

  if &number
    let lnrwidth = max([strlen(string(line('$'))) + 1, &numberwidth])
  elseif &relativenumber
    let lnrwidth = max([strlen(string(winheight('.'))) + 1, &numberwidth])
  else
    let lnrwidth = 0
  endif

  if &signcolumn ==# 'yes'
    let signwidth = 2
  elseif &signcolumn ==# 'no'
    let signwidth = 0
  elseif &signcolumn ==# 'number' && &number
    let signwidth = 0
  else
    " [{'signs': [...], 'bufnr': 2}]
    let signs = sign_getplaced(bufname(), {'group': '*'})
    if empty(signs[0]['signs'])
      let signwidth = 0
    else
      let signwidth = 2
    endif
  endif

  return lnrwidth + signwidth + &foldcolumn
endfunction "}}}

function! Foldtext() abort "{{{
  let comment = split(substitute(&commentstring, '\s', '', 'g'), '%s')
  let commentstart = len(comment) < 1 ? '' : comment[0]
  let commentend = len(comment) < 2 ? '' : comment[1]

  let left = getline(v:foldstart)
  let marker = strpart(&foldmarker, 0, stridx(&foldmarker, ',')) . '\d\*'

  " (コメント用の文字も含めて) マーカーを削除
  let pattern = printf('\V\s\*\(%s\)\?\s\*%s\s\*\(%s\|\.\*\$\)', commentstart, marker, commentend)
  let left = substitute(left, pattern, '', '')

  " コメント行の場合、コメント文字列のみにする
  let pattern = printf('\V\^\s\*\zs\(%s\)\?\s\*', commentstart)
  let left = substitute(left, pattern, '', '')

  " タブ文字を同じ幅のスペースに変換 (vartabstopには未対応)
  let left = substitute(left, '\t', repeat(' ', &tabstop), 'g')
  let leftlen = strwidth(left)

  let foldlinecount = foldclosedend(v:foldstart) - foldclosed(v:foldstart) + 1
  let right = printf(' %d [%d] ', foldlinecount, v:foldlevel)
  let rightlen = len(right)

  let linelen = winwidth('.') - s:winleftpad()

  " 表示する文字列が収まらないときに後ろの文字を畳む
  if leftlen + rightlen > linelen
    let leftlen = linelen - rightlen - 3
    while strwidth(left) > leftlen
      let left = strcharpart(left, 0, strchars(left) - 1)
    endwhile

    let left = left . '...'
    let leftlen = strwidth(left)
  endif

  let fill = repeat(' ', linelen - (leftlen + rightlen))

  return left . fill . right
endfunction "}}}

" cmapやcabbrev用 "{{{
function! Cmdwhen(mode, lhs, rhs) abort
  if getcmdtype() ==# a:mode
    return a:rhs
  else
    return a:lhs
  endif
endfunction "}}}

function! OpenSymbolicTarget() abort "{{{
  let filepath = resolve(expand('%:p'))

  " Windowsではgetftype()からlinkが返らない
  " 8.1.894以前だとresolve()でのパス解決もWindowsでは動かない
  if filepath ==# expand('%:p')
    echohl Error
    echo 'not symbolic link'
    echohl None

    return
  endif

  " バッファを開いてからカーソルを動かしていないときはカーソル位置を保存しない
  if getpos('.') !=# getpos("'\"")
    let view = winsaveview()
  endif

  " TODO: 別のタブも
  if winnr('$') > 1
    " すべてのウィンドウに対して閉じないようにしつつ対象のバッファを変更
    let bn = bufnr()
    let buflist = tabpagebuflist()
    call remove(buflist, index(buflist, bn))
    let tmpbn = buflist[0]
    let restwins = []

    for wn in range(1, winnr('$'))
      if winbufnr(wn) ==# bn
        call insert(restwins, wn)
        execute wn . 'windo' 'buffer' tmpbn
      endif
    endfor

    execute 'bwipeout' bn
    execute 'edit' filepath
    let bn = bufnr()

    for wn in restwins
      execute wn . 'windo' 'buffer' bn
    endfor
  else
    bwipeout
    execute 'edit' filepath
  endif

  if exists('l:view')
    call winrestview(view)
    normal! zv
  endif
endfunction "}}}

function! Mode() abort "{{{
  let mode = mode(1)

  let mode = substitute(mode, '\Cr', 'p', '')
  let mode = substitute(mode, '\C[SV]\zs', 'l', '')
  let mode = substitute(mode, "\\C\<C-v>", 'vr', '')
  let mode = substitute(mode, "\\C\<C-s>", 'sr', '')

  return toupper(mode[0]) . mode[1:]
endfunction "}}}
"}}}

" コマンド "{{{
cnoreabbrev <expr> w] Cmdwhen(':', 'w]', 'write')
cnoreabbrev <expr> new Cmdwhen(':', 'new', 'enew')
cnoreabbrev <expr> newtab Cmdwhen(':', 'newtab', 'tabnew')

" vimrc等を開く "{{{
let s:vimrc = expand('<sfile>')
let s:gvimrc = expand('<sfile>:h') . '/.gvimrc'

command! -bar -nargs=0 Evimrc edit `=s:vimrc`
command! -bar -nargs=0 Egvimrc edit `=s:gvimrc`
command! -bar -nargs=0 Svimrc source `=s:vimrc`
cnoreabbrev <expr> ev Cmdwhen(':', 'ev', 'Evimrc')
cnoreabbrev <expr> evimrc Cmdwhen(':', 'evimrc', 'Evimrc')
cnoreabbrev <expr> egv Cmdwhen(':', 'egv', 'Egvimrc')
cnoreabbrev <expr> egvimrc Cmdwhen(':', 'egvimrc', 'Egvimrc')
cnoreabbrev <expr> sv Cmdwhen(':', 'sv', 'Svimrc')
cnoreabbrev <expr> svimrc Cmdwhen(':', 'svimrc', 'Svimrc')

if g:vimrc#is_gui
  command! -bar -nargs=0 Sgvimrc source `=s:gvimrc`
  cnoreabbrev <expr> sgv Cmdwhen(':', 'sgv', 'Sgvimrc')
  cnoreabbrev <expr> sgvimrc Cmdwhen(':', 'sgvimrc', 'Sgvimrc')
endif "}}}

" setglobal, autocmd, highlight のラッパー "{{{
command! -complete=event -nargs=* Autocmd autocmd Vimrc <args>
command! -bar -complete=highlight -nargs=*
    \ Highlight Autocmd ColorScheme * highlight <args>

if g:vimrc#is_starting
  command -complete=filetype -nargs=*
      \ AutocmdFT Autocmd VimEnter * Autocmd FileType <args>
  command -bar -complete=option -nargs=* SetG set <args>

  Autocmd VimEnter * command! -complete=filetype -nargs=*
      \   AutocmdFT Autocmd FileType <args>
  Autocmd VimEnter * command! -bar -complete=option -nargs=*
      \   SetG setglobal <args>
else
  command! -complete=filetype -nargs=* AutocmdFT Autocmd FileType <args>
  command! -bar -complete=option -nargs=* SetG setglobal <args>
endif

" syntax "{{{
AutocmdFT vim
    \ syntax keyword vimAutoCmd Autocmd skipwhite nextgroup=vimAutoEventList
AutocmdFT vim
    \ syntax keyword vimAutoCmd AutocmdFT nextgroup=vimAutoCmdSpace
AutocmdFT vim
    \ syntax keyword vimHighlight Highlight skipwhite nextgroup=vimHiBang,@vimHighlightCluster
AutocmdFT vim
    \ syntax keyword vimCommand contained SetG
AutocmdFT vim
    \ syntax region vimSet matchgroup=vimCommand start="\<\%(SetG\)\>" skip="\%(\\\\\)*\\.\n\@!" end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vim9Comment,vimSetString,vimSetMod
"}}}
"}}}

" シンボリックリンク先のファイルを開く "{{{
command! -bar OpenSymbolicTarget call OpenSymbolicTarget()
"}}}

" Terminal "{{{
if g:vimrc#is_nvim
  command! -bar Terminal execute 'belowright 15new term://' . &shell
  cnoreabbrev <expr> terminal Cmdwhen(':', 'terminal', 'Terminal')
endif
"}}}

if !exists(':DiffOrig') "{{{
  command -bar -nargs=0 DiffOrig
      \ vertical new | setlocal buftype=nofile |
      \ read ++edit # | 0d_ | diffthis | wincmd p | diffthis
endif "}}}
"}}}

" オプション "{{{
" options "{{{
set ambiwidth=single
SetG autoindent cindent copyindent smartindent
SetG expandtab shiftwidth=2 softtabstop=2 tabstop=4
set shiftround smarttab
SetG autoread
set backspace=indent,eol,start whichwrap+=h,l
set backup backupskip+=*~,*.o
let &backupdir = g:vimrc#dotvim . '/.backup'
set browsedir=buffer
SetG complete-=u | set completeopt=menuone,longest,preview pumheight=8
set cmdheight=2
set confirm
SetG cursorline
set diffopt+=context:2,vertical
set display=lastline,uhex
set fillchars=fold:\ ,stl:\ ,stlnc:\ ,vert:\|
SetG foldenable foldmethod=marker foldtext=Foldtext()
SetG formatoptions+=Bjmr
set guicursor=a:block-Cursor
set helpheight=10 helplang=ja
set hidden
set history=1000
set hlsearch ignorecase incsearch smartcase | nohlsearch
SetG iminsert=0 imsearch=-1
set laststatus=2
setglobal statusline =\ %2{Mode()}%{&paste?'\ \ \|\ p':''}
setglobal statusline+=\ \|\ %n
setglobal statusline+=\ \|\ %{pathshorten(fnamemodify(expand('%:p'),':.:h').'/')}
setglobal statusline+=\ \|\ %{&filetype!=#'netrw'?expand('%:t'):''}
setglobal statusline+=\ %R%M%{&modified\|\|&readonly?'\ ':''}
if has('patch-8.2.2854')
  setglobal statusline+=%<%{%g:actual_curwin==#win_getid()?'%#StatusLineNC#':'%#Comment#'%}
else
  setglobal statusline+=%<%#StatusLineNC#
endif
if exists('+showcmdloc')
  setglobal statusline+=\ %S
endif
setglobal statusline+=%=%*
setglobal statusline+=\ %{(empty(&fileencoding)?&encoding:&fileencoding).'/'.&fileformat}
setglobal statusline+=\ \|\ %{empty(&filetype)?&buftype==#'terminal'?'terminal':'?':&filetype}
setglobal statusline+=\ \|\ %4P
setglobal statusline+=\ \|%4l:%2c\ %#StatusLineNC#
set lazyredraw
SetG list | set listchars=tab:>\ ,nbsp:%
SetG matchpairs+=<:> | set showmatch
SetG modeline
set mouse=a
SetG nrformats+=alpha
SetG number relativenumber
set pastetoggle=<F2>
set scrolloff=2
set sessionoptions+=localoptions,resize,slash,unix sessionoptions-=blank
set shortmess+=mrx shortmess-=t shortmess-=T
set showcmd
set showtabline=2
SetG signcolumn=auto
set splitbelow splitright
set nostartofline
set switchbuf=useopen,usetab
SetG synmaxcol=800
set timeout ttimeout timeoutlen=700 ttimeoutlen=50
set title
set undoreload=20000 | SetG undofile undolevels=800
let &undodir = g:vimrc#dotvim . '/.undo'
set updatecount=0 | SetG noswapfile
set updatetime=2000
set viewoptions+=localoptions,slash,unix
let &viewdir = g:vimrc#dotvim . '/.view'
set viminfo-=<50 viminfo+=<100
set virtualedit+=block
set wildcharm=<Tab> wildignore+=*~,*.o wildignorecase wildmenu wildmode=longest:full
set winaltkeys=yes

if exists('+ballooneval')
  set ballooneval
endif
if exists('+balloonevalterm')
  set balloonevalterm
endif
if exists('+breakindent')
  SetG breakindent breakindentopt=shift:2
endif
if exists('+fixendofline')
  SetG nofixendofline
endif
if exists('+packpath')
  let &packpath .= ',' . g:vimrc#dotvim . '/pack'
endif
if exists('+showcmdloc')
  set showcmdloc=statusline
endif
if exists('+termguicolors') && !g:vimrc#is_windows
  set termguicolors
endif
if exists('+termwinsize')
  SetG termwinsize=15*0
endif

if has('unnamedplus')
  set clipboard^=unnamedplus
else
  set clipboard^=unnamed
endif
if has('patch-7.4.314')
  set shortmess+=c
endif
if has('patch-8.1.360')
  set diffopt+=algorithm:histogram
endif
if has('patch-8.2.4325')
  set wildoptions=pum
endif

if g:vimrc#is_nvim
  set clipboard=
elseif g:vimrc#is_wsl
  set clipboard=exclude:.*
else
  set clipboard=exclude:console\|linux
endif
if g:vimrc#is_unix
  set shell=bash
endif "}}}

" バックアップフォルダ等を作成 "{{{
for s:d in filter(
    \ [&backup || &writebackup || &patchmode !=# '' ? 'backupdir' : '',
    \   &swapfile ? 'directory' : '', &undofile ? 'undodir' : '',
    \   exists('+loadplugins') && &loadplugins ? 'packpath' : '',
    \   'viewdir'], 'v:val !=# ""')
  if s:d != '' && !s:mkdir(eval('&' . s:d))
    execute 'set' s:d . '&'
  endif
endfor
unlet s:d "}}}

" $VIMRUNTIME 以下の不要なプラグインを読み込まない "{{{
let g:loaded_2html_plugin = 1
let g:loaded_gzip = 1
let g:loaded_tar = 1
let g:loaded_tarPlugin = 1
let g:loaded_zip = 1
let g:loaded_zipPlugin = 1
let g:loaded_rrhelper = 1
let g:loaded_vimball = 1
let g:loaded_vimballPlugin = 1
let g:loaded_getscript = 1
let g:loaded_getscriptPlugin = 1
"}}}

" $VIMRUNTIME以下のプラグインの設定 "{{{
let g:netrw_clipboard = 0
let g:netrw_keepj = ""
let g:netrw_liststyle = 3
let g:netrw_sizestyle = "H"
let g:netrw_use_errorwindow = 2
let g:netrw_winsize = -15
let g:vim_indent_cont = shiftwidth()*2
"}}}
"}}}

" キーマップ "{{{
map <Nul> <C-Space>
map! <Nul> <C-Space>

" minttyだけ?
" map <C-j> <S-CR>
" map! <C-j> <S-CR>

noremap - ^
noremap ^ $
sunmap -
sunmap ^

" nnoremap gi '[v']
nnoremap go gi

vnoremap za zo

noremap iq i'
noremap iQ i"
nunmap iq
nunmap iQ
sunmap iq
sunmap iQ

" マッチした文字列を選択
" TODO: マッチした文字列内か判定
onoremap / //e<CR>

noremap j gj
noremap k gk
noremap gj j
noremap gk k
sunmap j
sunmap k
sunmap gj
sunmap gk

noremap c "_c
nnoremap C "_C
noremap D "_d
nnoremap DD "_dd
noremap x "_x
noremap X x
xnoremap p "_dP
sunmap c
ounmap c
sunmap D
ounmap D
sunmap x
ounmap x
sunmap X
ounmap X

noremap n nzzzv
noremap N Nzzzv
" nnoremap <silent> * :let stay_star_view = winsaveview()<cr>*:call winrestview(stay_star_view)<cr>
" vnoremap <silent> * :let stay_star_view = winsaveview()<cr>*:call winrestview(stay_star_view)<cr>
noremap * g*<C-o>
noremap # g#<C-o>
noremap g* *<C-o>
noremap g# #<C-o>
sunmap n
sunmap N
sunmap *
sunmap #
sunmap g*
sunmap g#

noremap <C-e> <C-e>j
noremap <C-y> <C-y>k
noremap <C-u> <C-u>zz
noremap <C-d> <C-d>zz
noremap <C-f> <C-f>zz
noremap <C-b> <C-b>zz
" noremap <ScrollWheelUp> 3<C-y>
" noremap <ScrollWheelDown> 3<C-e>

" inoremap <C-u> <C-p>
" cnoremap <C-u> <C-p>
cnoremap <C-g> <C-u>

nnoremap Y y$
noremap! jk <Esc>
nnoremap <Tab> <C-i>
nnoremap <S-Tab> <C-o>
" cnoremap <Esc><Esc> <C-c>

" noremap! <C-p> <Up>
" noremap! <C-l> <Down>
" inoremap <C-k> <Left>
" cnoremap <C-k> <Space><BS><Left>
" inoremap <C-@> <Right>
" cnoremap <C-@> <Space><BS><Right>

" inoremap <C-y> <C-o>^
" cnoremap <C-y> <Home>
" noremap! <C-b> <End>
" cnoremap <C-e> <C-y>

inoremap <BS> <C-g>u<BS>
inoremap <CR> <C-]><C-g>u<CR>

nnoremap gs :%s/
xnoremap gs :s/

noremap <F1> <Esc>:help<Space>
nnoremap <F1> :<C-u>help<Space>
inoremap <F1> <Esc>:help<Space>

nnoremap <CR> o<Esc>
nnoremap <expr> <S-CR> 'O<Esc>j' . v:count . 'k'
inoremap <C-CR> <C-o>o
nnoremap <C-Space> i<CR><Esc>
nnoremap <C-CR> i<CR><Esc>

inoremap <silent> <C-z> <C-o>:update<CR>
nnoremap <silent> <Space><Tab> :<C-u>nohlsearch<CR>

nnoremap <silent> <Space>tt :<C-u>tabnew<CR>
nnoremap <expr> gt <SID>delcount(v:count) .
    \ ((tabpagenr() + max([v:count - 1, 0])) % tabpagenr('$') + 1) . 'gt'

nnoremap <silent> <C-n> :<C-u><C-r>=v:count<CR>bnext<CR>
nnoremap <silent> <C-p> :<C-u><C-r>=v:count<CR>bprevious<CR>
nnoremap <silent> <Space>bn :<C-u><C-r>=v:count<CR>bnext<CR>
nnoremap <silent> <Space>bN :<C-u><C-r>=v:count<CR>bNext<CR>
nnoremap <silent> <Space>bp :<C-u><C-r>=v:count<CR>bprevious<CR>

nnoremap <silent> <Space>cn :<C-u><C-r>=v:count<CR>cnext<CR>
nnoremap <silent> <Space>cN :<C-u><C-r>=v:count<CR>cNext<CR>
nnoremap <silent> <Space>cp :<C-u><C-r>=v:count<CR>cprevious<CR>

nnoremap <silent> <Space>ln :<C-u><C-r>=v:count<CR>lnext<CR>
nnoremap <silent> <Space>lN :<C-u><C-r>=v:count<CR>lNext<CR>
nnoremap <silent> <Space>lp :<C-u><C-r>=v:count<CR>lprevious<CR>

nnoremap <silent> <Space>h
    \ :<C-u>echo map(synstack(line('.'),col('.')),'synIDattr(v:val,"name")')<CR>

let g:foldmethods = ['marker', 'indent', 'expr']
call add(g:foldmethods, g:foldmethods[0])
nnoremap <silent> <Space>sf
    \ :<C-u>setlocal foldmethod=<C-r>=g:foldmethods[index(g:foldmethods,&foldmethod)+1]<CR> foldmethod?<CR>zv

inoremap <Plug>(vimrc_cr) <CR>
inoremap <Plug>(vimrc_complete-select) <C-y>
imap <expr><silent> <CR> pumvisible() ? '<Plug>(vimrc_complete-select)' : '<Plug>(vimrc_cr)'
cnoremap <expr> <Tab> wildmenumode() ? '<C-n>' : '<Tab>'
inoremap <expr> <C-f> search('^\s*\%#', 'bcn', line('.')) > 0 ? '<C-f>' : '<C-x><C-f>'

tnoremap <ScrollWheelUp> <C-\><C-n>
tnoremap <ScrollWheelDown> <C-\><C-n>
"}}}

" エンコード "{{{
set fileformats=unix,dos,mac
set fileencodings=utf-8

if g:vimrc#is_cygwin
  set fileencodings+=cp932,euc-jp
elseif g:vimrc#is_windows
  set fileencodings+=cp932
else
  set fileencodings+=euc-jp,sjis
endif

" http://www.kawaz.jp/pukiwiki/?vim (404)
" http://pcmania.jp/~moraz/howto/install.html#japanese (404)
" Kaoriya Vim 6 のvimrcから？ (http://elpeo.jp/diary/20031113p01.html)
" ファイルの漢字コード自動判別のために必要 (要iconv)
if has('iconv')
  set fileencodings-=euc-jp

  " iconvがeucJP-msに対応しているかをチェック
  if iconv('\x87\x64\x87\x6a', 'cp932', 'eucjp-ms') ==# '\xad\xc5\xad\xcb'
    let s:enc_euc = 'eucjp-ms'
    let s:enc_jis = 'iso-2022-jp-3'
    " iconvがJISX0213に対応しているかをチェック
  elseif iconv('\x87\x64\x87\x6a', 'cp932', 'euc-jisx0213') ==# '\xad\xc5\xad\xcb'
    let s:enc_euc = 'euc-jisx0213'
    let s:enc_jis = 'iso-2022-jp-3'
  else
    let s:enc_euc = 'euc-jp'
    let s:enc_jis = 'iso-2022-jp'
  endif

  " fileencodingsを構築
  if &encoding ==# 'utf-8'
    set fileencodings-=cp932 fileencodings-=sjis
    let &fileencodings = s:enc_jis . ',' . s:enc_euc .
        \ (g:vimrc#is_windows ? ',cp932,' : ',sjis,') . &fileencodings
  else
    set fileencodings-=utf-8 fileencodings-=ucs-2le fileencodings-=ucs-2
    let &fileencodings .= ',' . s:enc_jis . ',utf-8,ucs-2le,ucs-2'

    if &encoding =~# '^\(euc-jp\|euc-jisx0213\|eucjp-ms\)$'
      set fileencodings-=euc-jp fileencodings-=euc-jisx0213 fileencodings-=eucjp-ms
      let &encoding = s:enc_euc
      let &g:fileencoding = s:enc_euc
    else
      let &fileencodings .= ',' . s:enc_euc
    endif
  endif

  unlet s:enc_euc
  unlet s:enc_jis
endif

" encodingをfileencodingsの最後に移動
execute 'set fileencodings-=' . &encoding
execute 'set fileencodings+=' . &encoding

" 日本語を含まない場合は fileencoding に encoding を使うようにする
Autocmd BufReadPost,FileReadPost,FilterReadPost *
    \ if &fileencoding=~#'iso-2022-jp' && search("[^\x01-\x7e]", 'n')==0 |
    \   let &fileencoding = &encoding | endif "}}}

" terminal "{{{
" https://ttssh2.osdn.jp/manual/4/ja/usage/tips/vim.html
if !g:vimrc#is_gui && &term !~# 'cygwin\|win32\|linux' " &term =~# 'xterm' &&
  " set t_Co=256

  " for RLogin "{{{
  if &term ==# 'rlogin-color' && !g:vimrc#is_nvim
    if g:vimrc#is_starting
      " true color
      let &t_8f = "\e[38:2:%lu:%lu:%lum"
      let &t_8b = "\e[48:2:%lu:%lu:%lum"
      " let &t_8u = ""

      " 端末へ情報を要求
      let &t_RF = "\e]10;?\x07"
      let &t_RB = "\e]11;?\x07"
      let &t_RV = "\e[>c"

      " 下線
      " let &t_AU = ""
      " let &t_Ce = ""
      " let &t_Cs = ""

      " 打ち消し線
      let &t_Ts = "\e[9m"
      let &t_Te = "\e[29m"

      " カーソル
      let &t_RC = "\e[?12$p"
      let &t_VS = "\e[?12h"
      let &t_vs = "\e[?12l"
      " let &t_RS = ""
      " let &t_SC = "\e[<"
      " let &t_EC = "!q"
      let &t_SH = "\e[%p1%d q"

      " ウィンドウサイズ
      let &t_WS = "\e[8;%p1%d;%p2%dt"

      " ウィンドウタイトル
      let &t_ST = "\e[22;0t"
      let &t_RT = "\e[23;0t"

      " アイコンテキスト
      let &t_IS = "\e]1;"
      let &t_IE = "\x07"
      let &t_Si = "\e[22;0t"
      let &t_Ri = "\e[23;0t"

      " blacketed paste mode
      let &t_BE = "\e[?2004h"
      let &t_BD = "\e[?2004l"
      let &t_PS = "\e[200~"
      let &t_PE = "\e[201~"

      " フォーカスイベント
      let &t_fe = "\e[?1004h"
      let &t_fd = "\e[?1004l"
    endif

    execute "set <FocusGained>=\e[I"
    execute "set <FocusLost>=\e[O"
  " endif

  " modifyOtherKeys "{{{
  " if GetXTVersion() =~# '^RLogin' " 応答がキー入力扱いになってしまうので無効化
    " modifyCursorKeysとmodifyStringKeysも有効にする
    if g:vimrc#is_starting
      " 有効にすると一部のキー(DD, <C-r>")で問題があるのでmodifyOtherKeys以外を一旦無効化
      " let &t_TI = "\e[>1;2m\e[>4;2m\e[>5;2m"
      " let &t_TE = "\e[>1;m\e[>4;m\e[>5;m"
      let &t_TI = "\e[>4;2m"
      let &t_TE = "\e[>4;m"
    endif

    " Seen modifyOtherKeys: true にならないようにキーコードに対してマッピングする
    let s:modifers = [
        \   {'name': 'S', 'code': 2},
        \   {'name': 'A', 'code': 3},
        \   {'name': 'A-S', 'code': 4},
        \   {'name': 'C', 'code': 5},
        \   {'name': 'C-S', 'code': 6},
        \   {'name': 'A-C', 'code': 7},
        \   {'name': 'A-C-S', 'code': 8}
        \ ]
    let s:keys = [
        \   {'name': 'BS', 'code': 8},
        \   {'name': 'Tab', 'code': 9},
        \   {'name': 'CR', 'code': 13}
        \ ]

    for s:modifer in s:modifers
      for s:key in s:keys
        execute 'map <special>'
            \ printf('<Esc>[27;%d;%d~', s:modifer['code'], s:key['code'])
            \ printf('<%s-%s>', s:modifer['name'], s:key['name'])
        execute 'map! <special>'
            \ printf('<Esc>[27;%d;%d~', s:modifer['code'], s:key['code'])
            \ printf('<%s-%s>', s:modifer['name'], s:key['name'])
      endfor
    endfor
    unlet s:modifers s:modifer s:keys s:key

    cnoremap <special><expr> <S-Tab> wildmenumode() ? '<C-p>' : '<Tab>'
  endif "}}}
  "}}}

  " Shift-Insertのペースト時に自動でpastetoggle "{{{
  " https://qiita.com/ringo/items/bb9cf61a3ccfe6183c7b
  " https://qiita.com/kefir_/items/415a30930a80b9b42adb
  if !has("patch-8.0.238") && !g:vimrc#is_nvim
    if g:vimrc#is_starting
      if has("patch-8.0.210")
          set t_BE=
      endif

      let &t_ti .= "\e[?2004h"
      " let &t_te .= "\e[?2004l"
      let &t_te = "\e[?2004l" . &t_te
      let &pastetoggle = "\e[201~"
    endif

    function! s:xTermPasteBegin(ret) abort
      set paste
      return a:ret
    endfunction

    " noremap <special> <expr> <Esc>[200~ XTermPasteBegin('0i')
    noremap <special> <expr> <Esc>[200~ <SID>xTermPasteBegin('i')
    inoremap <special> <expr> <Esc>[200~ <SID>xTermPasteBegin('')
    cnoremap <special> <Esc>[200~ <nop>
    cnoremap <special> <Esc>[201~ <nop>

    map <F2> <Esc>[201~
    imap <F2> <Esc>[201~
  endif "}}}

  " OSC52でのコピー "{{{
  function s:paste64(text) abort
    let str = join(systemlist('base64 --wrap=0', a:text), '')

    let seq = printf("\e]52;;%s\e\\", str)
    if g:vimrc#is_nvim
      let blob = [seq]
    else
      let blob = list2blob(str2list(seq))
    endif

    call writefile(blob, '/dev/tty', 'a')

    if g:vimrc#is_nvim
      redraw!
    endif
  endfunction

  nnoremap <silent> <Space>y :<C-u>call <SID>paste64(@")<CR>
  "}}}

  " 挿入モードを出るときにIMEを自動で切る "{{{
  " https://qiita.com/U25CE/items/0b40662a22162907efae#%E7%AB%AF%E6%9C%AB%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3
  if g:vimrc#is_starting && !g:vimrc#is_nvim
    let &t_SI .= "\e[<r"
    let &t_EI .= "\e[<s\e[<0t"
    let &t_te .= "\e[<0\e[<s"
  endif "}}}

  " 挿入モードでのESCキーの待ちをなくす "{{{
  inoremap <special> <Esc>O[ <Esc>
  inoremap <special> <C-V><Esc>O[ <C-V><Esc>
  inoremap <special> <C-r><Esc>O[ <Nop>
  noremap <special> r<Esc>O[ <Nop>
  noremap <special> r<C-v><Esc>O[ r<Esc>

  if g:vimrc#is_starting && !g:vimrc#is_nvim
    let &t_SI .= "\e[?7727h"
    let &t_EI .= "\e[?7727l"
  endif "}}}

  " 縦分割時のスクロールの高速化 "{{{
  " https://qiita.com/kefir_/items/c725731d33de4d8fb096
  if 0 && !g:vimrc#is_nvim
    set nottyfast
    function! s:enableVsplitMode() abort "{{{
      " enable origin mode and left/right margins
      let &t_CS = 'y'
      let &t_CV = "\e[%i%p1%d;%p2%ds"
      let &t_te = "\e[?6;69l" . &t_te
      " let &t_te = "\e[?6;69l\e[999H" . &t_te
      " let &t_te = "\e7\e[?6;69l\e8" . &t_te
      " let &t_te .= "\e[?6;69l"
      " let &t_te .= "\e[?6;69l\e[999H"
      " let &t_te .= "\e7\e[?6;69l\e8"
      let &t_ti .= "\e[?6;69h"
      "   call writefile(["\e[?6h\e[?69h"], '/dev/tty', 'a')
      call writefile(["\e[?6;69h"], '/dev/tty', 'a')
    endfunction "}}}

    " old vim does not ignore CPR
    " map <special> <Esc>[3;9R <Nop>

    " new vim can't handle CPR with direct mapping
    " map <expr> [3;3R <SID>enableVsplitMode()
    " set t_F9=[3;3R
    map <Esc>[3;3R <t_F9>
    map <expr> <t_F9> <SID>enableVsplitMode()

    if g:vimrc#is_starting
      let &t_RV .= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
    endif
  endif "}}}

  " Vim終了時にウィンドウタイトルを起動前の状態に戻す "{{{
  if !has("patch-8.1.0253") && g:vimrc#is_starting && !g:vimrc#is_nvim
    let &t_ti .= "\e[22;0t"
    let &t_te .= "\e[23;0t"
  endif "}}}

  " バージョン情報を取得 "{{{
  " 応答が DCS (ESC P) > | VERSION ST (ESC \)で返ってくるのでどうにかして取得
  " Neovimだと応答が取れない?
  function! GetXTVersion() abort
    " unmap <Esc>P><Bar>
    " let &t_ti = substitute(&t_ti, "\e[>0q", '', '')

    if exists('g:xtversion')
      return g:xtversion
    endif

    call writefile(list2blob(str2list("\e[>0q")), '/dev/tty', 'a')
    sleep 200m
    call s:parse_response()

    return g:xtversion
  endfunction

  function! s:parse_response() abort
    let res = []
    let i = 1
    while 1
      let c = getchar(0)
      " echomsg printf("%d, %s", i, string(c))
      if !c
        break
      elseif i ==# 1 && c ==# char2nr("\e")
        let i += 1
      elseif i ==# 2 && c ==# char2nr('P')
        let i += 1
      elseif i ==# 3 && c ==# char2nr('>')
        let i += 1
      elseif i ==# 4 && c ==# char2nr('|')
        let i += 1
      elseif i ==# 5
        if c ==# char2nr("\e")
          let i += 1
        else
          let res += [c]
        endif
      elseif i ==# 6 && c ==# char2nr('\')
        break
      else
        echomsg 'wrong response'
        while getchar(0) | endwhile
        break
      endif
    endwhile

    let g:xtversion = list2str(res)
  endfunction

  " if g:vimrc#is_starting && !g:vimrc#is_nvim
    " nnoremap <special><expr> <Esc>P><Bar> GetXTVersion()
    " let &t_ti .= "\e[>0q"
  " endif "}}}
endif "}}}

" ColorScheme "{{{
set background=dark
Highlight ColorColumn ctermbg=233 guibg=#181818
" Highlight Folded ctermfg=247 ctermbg=234 guibg=#303030

Highlight CursorLineNr ctermbg=NONE guibg=NONE
" Highlight LineNr ctermfg=darkgreen guifg=#00c000
Highlight SignColumn ctermbg=NONE guibg=NONE
" Highlight StatusLineNC ctermfg=235

" Highlight TabLineFill ctermfg=236

" Highlight Pmenu ctermfg=black ctermbg=lightgray guifg=black guibg=lightgray
" Highlight PmenuSbar ctermfg=black guifg=black
" Highlight PmenuSel ctermfg=yellow ctermbg=darkblue guifg=yellow guibg=blue
" Highlight PmenuThumb ctermfg=darkblue guifg=blue

" Highlight DiffChange ctermbg=25 guibg=#004060
" Highlight DiffText ctermbg=18 guibg=#000080
Highlight DiffAdd guifg=NONE
Highlight DiffChange guifg=NONE
Highlight DiffDelete guifg=NONE
Highlight DiffText guifg=NONE

" コメントのハイライトがおかしいので以前のシンタックスを適用
" https://github.com/vim/vim/issues/11307
if has('patch-9.0.652')
  AutocmdFT vim syntax match vimLineComment +^[ \t:]*".*$+ contains=@vimCommentGroup,vimCommentString,vimCommentTitle
endif
"}}}

" autocmd "{{{
" カレントウィンドウのみカーソル行を強調 "{{{
Autocmd WinLeave * setlocal nocursorline
Autocmd WinEnter,BufWinEnter * setlocal cursorline
"}}}

" 保存したときのカーソル位置へ移動 "{{{
Autocmd BufReadPost ?*
    \ if line("'\"") > 0 && line ("'\"") <= line('$') |
    \   execute "normal! g'\"zv" |
    \ endif
"}}}

" 画面の81桁目にcolorcolumnを表示 "{{{
Autocmd BufEnter,BufWinEnter,ColorScheme,FileType *
    \ let &colorcolumn = 81 - s:winleftpad()
Autocmd OptionSet foldcolumn,number,numberwidth,relativenumber,signcolumn
    \ let &colorcolumn = 81 - s:winleftpad()
"}}}

" その他 "{{{
" Autocmd QuickfixCmdPost make call QfMakeConv(&fileencoding, &encoding)
" if g:vimrc#is_windows
"   Autocmd QuickfixCmdPost make call QfMakeConv('utf-8', 'cp932')
" else
"   Autocmd QuickfixCmdPost make call QfMakeConv('cp932', 'utf-8')
" endif

AutocmdFT * setlocal formatoptions-=o
" AutocmdFT * if &commentstring !~# '^ ' |
"    \ let &commentstring = ' ' . &commentstring | endif
AutocmdFT c setlocal omnifunc=ccomplete#Complete
AutocmdFT * if &omnifunc ==# '' |
    \ setlocal omnifunc=syntaxcomplete#Complete | endif
AutocmdFT git,help,netrw,qf
    \ noremap <buffer><silent> q :<C-u>bwipeout<CR>
AutocmdFT qf
    \ nnoremap <buffer><silent> <CR> :<C-u>execute 'cc!' line('.')<CR>
Autocmd CmdwinEnter * nnoremap <buffer><silent> q :<C-u>q<CR>
AutocmdFT vim,help setlocal keywordprg=:help
Autocmd BufNewFile *.bat setlocal fileencoding=cp932 fileformat=dos
execute 'Autocmd BufReadPre' &backupskip 'setlocal noundofile'
" Autocmd CmdlineChanged : if !wildmenumode() && len(getcompletion(getcmdline(), 'cmdline')) > 1 | call feedkeys("\<Tab>") | endif
if g:vimrc#is_nvim
  Autocmd TermOpen * setlocal nobuflisted nonumber norelativenumber winfixheight
  Autocmd TermOpen * nnoremap <buffer><silent><expr> q term_getstatus(bufnr()) =~# 'finished' ? ':<C-u>q<CR>' : ''
  Autocmd TermOpen * startinsert
  Autocmd TermClose * if !v:event.status | execute 'bdelete! ' . expand('<abuf>') | endif
elseif has('terminal')
  if exists('##TerminalWinOpen')
    Autocmd TerminalWinOpen * setlocal nobuflisted nonumber norelativenumber winfixheight
    Autocmd TerminalWinOpen * nnoremap <buffer><silent><expr> q term_getstatus(bufnr()) =~# 'finished' ? ':<C-u>q<CR>' : ''
  else
    Autocmd TerminalOpen * setlocal nobuflisted nonumber norelativenumber winfixheight
    Autocmd TerminalOpen * nnoremap <buffer><silent><expr> q term_getstatus(bufnr()) =~# 'finished' ? ':<C-u>q<CR>' : ''
  endif
endif
Autocmd BufWinEnter,ColorScheme,FileType * call HighlightTrailingSpace()
AutocmdFT diff setlocal vartabstop=9,8

augroup Vimrc_bin
  autocmd!
  autocmd BufReadPre *.bin,*.exe,*.dll setlocal binary
  autocmd BufReadPost *
      \ if &binary |
      \   execute 'silent %!xxd -g 1' |
      \   setlocal filetype=xxd noendofline |
      \   execute 'Autocmd BufWritePre <buffer=abuf> %!xxd -r' |
      \   execute 'Autocmd BufWritePost <buffer=abuf> silent %!xxd -g 1' |
      \   execute 'Autocmd BufWritePost <buffer=abuf> setlocal nomodified' |
      \ endif
augroup END
"}}}
"}}}

" plugin "{{{
if has('patch-7.4.1649')
  packadd! matchit
else
  runtime macros/matchit.vim
endif

" 画面切り替え前のメッセージを遅延させる
redir => s:msg
silent execute 'source' g:vimrc#dotvim . '/dein.vim'
silent runtime! plugin/**/*.vim
redir END
Autocmd VimEnter *
    \ for line in split(s:msg, "\n") |
    \   echomsg line |
    \ endfor
"}}}

Autocmd VimEnter * doautocmd Vimrc FileType

if get(g:, 'colors_name', '') ==# ''
  colorscheme desert
endif

filetype plugin indent on
syntax on

if !g:vimrc#is_starting
  doautocmd Vimrc VimEnter
endif
