" don't load when -eval(vim-tiny, vim-small)
if 0 | endif

" Initialize "{{{
if &compatible | set compatible! | endif

if !exists('g:vimrc#is_starting')
  let g:vimrc#is_windows = has('win32')
  let g:vimrc#is_cygwin = has('win32unix')
  let g:vimrc#is_unix = has('unix') && !g:vimrc#is_cygwin
  let g:vimrc#is_wsl = g:vimrc#is_unix && system('uname -r') =~? 'microsoft'
  let g:vimrc#is_nvim = has('nvim')
  if g:vimrc#is_nvim
    let g:vimrc#is_gui = nvim_list_uis()[0].chan ==# 1
  else
    let g:vimrc#is_gui = has('gui_running')
  endif
  let g:vimrc#is_starting = 1
  let g:vimrc#dotvim = expand('~/.vim')
endif

augroup Vimrc
  autocmd!
  autocmd VimEnter * let g:vimrc#is_starting = 0
augroup END "}}}

" use Vim with singleton "{{{
if has('clientserver') && !exists('g:loaded_editexisting')
  let g:loaded_editexisting = 1
  if has('patch-7.4.1674')
    packadd! editexisting
  else
    runtime macros/editexisting.vim
  endif
endif "}}}

" print startup time "{{{
" https://gist.github.com/thinca/1518874#file-vimrc-L20
if g:vimrc#is_starting && has('reltime')
  let s:startuptime = reltime()
  " :redraw hides intro message
  augroup vimrc-startuptime
    autocmd! VimEnter *
        \ let s:startuptime = reltime(s:startuptime) |
        \ echomsg 'startuptime: ' . reltimestr(s:startuptime) |
        \ unlet s:startuptime | autocmd! vimrc-startuptime
  augroup END
endif "}}}

" encoding "{{{
" if &encoding !=# 'utf-8'
if &term ==# 'win32' " command prompt
  set encoding=cp932
else
  set encoding=utf-8
endif

if g:vimrc#is_windows
  set termencoding=cp932
  setglobal fileencoding=cp932
else
  set termencoding=utf-8
  setglobal fileencoding=utf-8
endif

" setglobal fileencoding=japan
" endif

scriptencoding utf-8 "}}}

" functions "{{{
function! s:mkdir(path) abort "{{{
  " return: ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’èª­ã¿è¾¼ã‚ãªã„(ä½œæˆã§ããªã„)ã¨ã0, ãã‚Œä»¥å¤–ã¯1
  if a:path =~# '^.\{-}://' " Non local file, ignore
    return 0
  endif

  for p in split(a:path, ',')
    if !isdirectory(p)
      if !filereadable(p) && !filewritable(p)
        call mkdir(p, 'p')
        return 1
      endif
    else
      return 1
    endif
  endfor

  echoerr a:path . ' should be directory and readable.'
  return 0
endfunction "}}}

" quickfixãƒªã‚¹ãƒˆã®æ–‡å­—åŒ–ã‘å›é¿ "{{{
function! QfMakeConv(fenc, enc) abort
  let qflist = getqflist()
  for i in qflist
    let i.text = iconv(i.text, a:fenc, a:enc)
  endfor
  call setqflist(qflist, 'r')
endfunction "}}}

" å¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ãƒ­ãƒ¼ã‚«ãƒ«é–¢æ•°ã‚’å‘¼ã³å‡ºã™ "{{{
" https://thinca.hatenablog.com/entry/20111228/1325077104
function! CallInternalFunc(f, ...) abort
  let [file, func] = a:f =~# ':' ?  split(a:f, ':') : [expand('%:p'), a:f]
  let fname = matchstr(func, '^\w*')
  let cfunc = ''

  " Get sourced scripts.
  redir => slist
  silent scriptnames
  redir END

  let filepat = '\V' . substitute(file, '\\', '/', 'g') . '\v%(\.vim)?$'
  for s in split(slist, "\n")
    let p = matchlist(s, '^\s*\(\d\+\):\s*\(.*\)$')
    if empty(p)
      continue
    endif
    let [nr, sfile] = p[1 : 2]
    let sfile = fnamemodify(sfile, ':p:gs?\\?/?')
    if sfile =~# filepat && exists(printf("*\<SNR>%d_%s", nr, fname))
      let cfunc = printf("\<SNR>%d_%s", nr, func)
      break
    endif
  endfor

  if !exists('nr')
    echoerr 'Not sourced: ' . file
    return
  elseif !exists('cfunc')
    let file = fnamemodify(file, ':p')
    echoerr printf(
        \ 'File found, but function is not defined: %s: %s()', file, fname)
    return
  endif

  return 0 <= match(func, '^\w*\s*(.*)\s*$')
      \ ? eval(cfunc) : call(cfunc, a:000)
endfunction "}}}

" ãƒãƒƒãƒ—æ™‚ã®v:countã‚’<Esc>ã‚’ä½¿ã‚ãšã«å‰Šé™¤ "{{{
" ex. noremap <expr> j <SID>delcount(v:count) . 'gj'
function! s:delcount(count) abort
  return !a:count ? '' : repeat("\<Del>", strlen(string(a:count)))
endfunction "}}}

" è‡ªå‹•ã§ç”Ÿæˆã•ã‚Œã‚‹ãƒãƒƒãƒ•ã‚¡ã‹åˆ¤å®š "{{{
let g:vimrc#generate_filetypes = ['git', 'help', 'netrw', 'qf']

" a:1 - ãƒãƒƒãƒ•ã‚¡ç•ªå· (0ã®ã¨ãç¾åœ¨ã®ãƒãƒƒãƒ•ã‚¡ã«å¯¾ã—ã¦åˆ¤å®š)
function! s:ignore(...) abort
  if a:0 && a:1 !=# 0
    let bh = getbufvar(a:1, '&bufhidden')
    let bl = getbufvar(a:1, '&buflisted')
    let bname = fnamemodify(bufname(a:1), ':t')
    let bt = getbufvar(a:1, '&buftype')
    let fts = getbufvar(a:1, '&filetype')
    let wt = exists('*win_gettype') ? win_gettype(bufwinnr(a:1)) : ''
  else
    let bh = &bufhidden
    let bl = &buflisted
    let bname = expand('%:t')
    let bt = &buftype
    let fts = &filetype
    let wt = exists('*win_gettype') ? win_gettype() : ''
  endif

  if !bl
    return 1
  endif

  if !empty(bt)
    return 1
  endif

  if !(bh ==# '' ? &hidden : bh ==# 'hide')
    return 1
  endif

  if !(wt ==# '' || wt ==# 'unknown')
    return 1
  endif

  for ft in split(fts, '\.')
    if index(g:vimrc#generate_filetypes, ft) !=# -1
      return 1
    endif
  endfor

  return bname =~# '^\[Command\ Line\]$'
endfunction "}}}

" è¡Œæœ«ã®ç©ºç™½ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ "{{{
function! HighlightTrailingSpace() abort
  if s:ignore()
    if get(w:, 'spaceid', 0)
      call matchdelete(w:spaceid)
      unlet w:spaceid
    endif
  else
    highlight TrailingWhiteSpace ctermbg=darkred guibg=#ff0000
    if !get(w:, 'spaceid', 0)
      " è¡Œæœ«ã®ç©ºç™½ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
      let w:spaceid = matchadd('TrailingWhiteSpace', '\s\+$', 11)
    endif
  endif
endfunction "}}}

" æŒ‡å®šç¯„å›²ã®ç©ºè¡Œã‚’å‰Šé™¤ "{{{
function! s:delemptyline(start, last) abort
  " return: å‰Šé™¤ã—ãŸè¡Œã®æ•°
  let save_cursor = getcurpos()

  let n = 0 | let end = a:last
  call cursor(a:start, 1)
  while 1
    let l = search('^$', 'c', end)
    if l <= 0 | break | endif

    execute l . 'delete' '_'
    let n += 1 | let end -= 1
  endwhile

  call setpos('.', save_cursor)
  return n
endfunction "}}}

" ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’æ¶ˆã—ã¦çµåˆ(J) "{{{
function! s:J() range
  set operatorfunc=Concat
  return 'g@' . max([a:lastline - a:firstline - 1, 1]) . 'j'
endfunction

function! Concat(type) abort
  let js_save = &joinspaces
  let sel_save = &selection
  set selection=inclusive

  let startline = line("'[")
  let endline = line("']")

  if startline ==# endline
    let endline += 1
  endif

  let endline -= s:delemptyline(startline, endline)
  if startline < endline
    let lines = getline(startline + 1, endline)

    " ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ä¸­ã§ã¯çµåˆæ™‚ã«ç©ºç™½ã‚’å…¥ã‚Œãªã„
    if &filetype !~# '\v(\.|^)text(\.|$)'
      let synname = synIDattr(synID(startline, col('$') - 1, 1), "name")
      if synname !~# '\v(Comment|String)$'
        set nojoinspaces
      else
        " call map(lines, "substitute(v:val, '^\\s*' . substitute(&commentstring, '^\\s*\\|%s', '', 'g'), '', '')")
      endif
    endif

    if &filetype =~# '\v(\.|^)vim(\.|$)'
      " è¡Œç¶™ç¶šã‚’å‰Šé™¤
      call map(lines, "substitute(v:val, '^\\s*\\\\', '', '')")

      " foldmarkerã®ã‚³ãƒ¡ãƒ³ãƒˆæ–‡å­—ã¯æ®‹ã™
      let [foldstart, foldend] = split(&foldmarker, ',')
      call map(lines, printf("substitute(v:val, '\\ze\"\\s*%s', '\" ', '')", foldstart)) " not vim9script
      let lines = [getline(startline)] + lines
    else
      let lastline = lines[-1]
      let lines = [getline(startline)] + lines[:-2]

      " è¡Œç¶™ç¶šã‚’å‰Šé™¤
      call map(lines, "substitute(v:val, '\\\\$', '', '')")

      let lines += [lastline]
    endif

    call setline(startline, lines)
    execute 'join' endline - startline + 1
  endif

  let &joinspaces = js_save
  let &selection = sel_save
endfunction

noremap <expr> J <SID>J()
noremap <Space>J J
sunmap J
ounmap J
sunmap <Space>J
ounmap <Space>J

nnoremap <silent> <Space><Space>J :<C-u>set operatorfunc=Concat<CR>g@
nnoremap <silent> <Space><Space>JJ :<C-u>set operatorfunc=Concat<CR>g@g@
"}}}

" ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®å·¦å´ã®ä½™ç™½ã®å¹… "{{{
function! s:winleftpad() abort
  if g:vimrc#is_nvim || has('patch-8.2.3627')
    return getwininfo(win_getid())[0]['textoff']
  endif

  if &number
    let lnrwidth = max([strlen(string(line('$'))) + 1, &numberwidth])
  elseif &relativenumber
    let lnrwidth = max([strlen(string(winheight('.'))) + 1, &numberwidth])
  else
    let lnrwidth = 0
  endif

  if &signcolumn ==# 'yes'
    let signwidth = 2
  elseif &signcolumn ==# 'no'
    let signwidth = 0
  elseif &signcolumn ==# 'number' && &number
    let signwidth = 0
  else
    " [{'signs': [...], 'bufnr': 2}]
    let signs = sign_getplaced(bufname(), {'group': '*'})
    if empty(signs[0]['signs'])
      let signwidth = 0
    else
      let signwidth = 2
    endif
  endif

  return lnrwidth + signwidth + &foldcolumn
endfunction "}}}

function! Foldtext() abort "{{{
  let comment = split(substitute(&commentstring, '\s', '', 'g'), '%s')
  let commentstart = len(comment) < 1 ? '' : comment[0]
  let commentend = len(comment) < 2 ? '' : comment[1]

  let left = getline(v:foldstart)
  let marker = strpart(&foldmarker, 0, stridx(&foldmarker, ',')) . '\d\*'

  " (ã‚³ãƒ¡ãƒ³ãƒˆç”¨ã®æ–‡å­—ã‚‚å«ã‚ã¦) ãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤
  let pattern = printf('\V\s\*\(%s\)\?\s\*%s\s\*\(%s\|\.\*\$\)', commentstart, marker, commentend)
  let left = substitute(left, pattern, '', '')

  " ã‚³ãƒ¡ãƒ³ãƒˆè¡Œã®å ´åˆã€ã‚³ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã®ã¿ã«ã™ã‚‹
  let pattern = printf('\V\^\s\*\zs\(%s\)\?\s\*', commentstart)
  let left = substitute(left, pattern, '', '')

  " ã‚¿ãƒ–æ–‡å­—ã‚’åŒã˜å¹…ã®ã‚¹ãƒšãƒ¼ã‚¹ã«å¤‰æ› (vartabstopã«ã¯æœªå¯¾å¿œ)
  let left = substitute(left, '\t', repeat(' ', &tabstop), 'g')
  let leftlen = strwidth(left)

  let foldlinecount = foldclosedend(v:foldstart) - foldclosed(v:foldstart) + 1
  let right = printf(' %d [%d] ', foldlinecount, v:foldlevel)
  let rightlen = len(right)

  let linelen = winwidth('.') - s:winleftpad()

  " è¡¨ç¤ºã™ã‚‹æ–‡å­—åˆ—ãŒåã¾ã‚‰ãªã„ã¨ãã«å¾Œã‚ã®æ–‡å­—ã‚’ç•³ã‚€
  if leftlen + rightlen > linelen
    let leftlen = linelen - rightlen - 3
    while strwidth(left) > leftlen
      let left = strcharpart(left, 0, strchars(left) - 1)
    endwhile

    let left = left . '...'
    let leftlen = strwidth(left)
  endif

  let fill = repeat(' ', linelen - (leftlen + rightlen))

  return left . fill . right
endfunction "}}}

" cmapã‚„cabbrevç”¨ "{{{
function! Cmdwhen(mode, lhs, rhs) abort
  if getcmdtype() ==# a:mode
    return a:rhs
  else
    return a:lhs
  endif
endfunction "}}}

function! OpenSymbolicTarget() abort "{{{
  let filepath = resolve(expand('%:p'))

  " Windowsã§ã¯getftype()ã‹ã‚‰linkãŒè¿”ã‚‰ãªã„
  " 8.1.894ä»¥å‰ã ã¨resolve()ã§ã®ãƒ‘ã‚¹è§£æ±ºã‚‚Windowsã§ã¯å‹•ã‹ãªã„
  if filepath ==# expand('%:p')
    echohl Error
    echo 'not symbolic link'
    echohl None

    return
  endif

  " ãƒãƒƒãƒ•ã‚¡ã‚’é–‹ã„ã¦ã‹ã‚‰ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã—ã¦ã„ãªã„ã¨ãã¯ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’ä¿å­˜ã—ãªã„
  if getpos('.') !=# getpos("'\"")
    let view = winsaveview()
  endif

  " TODO: åˆ¥ã®ã‚¿ãƒ–ã‚‚
  if winnr('$') > 1
    " ã™ã¹ã¦ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«å¯¾ã—ã¦é–‰ã˜ãªã„ã‚ˆã†ã«ã—ã¤ã¤å¯¾è±¡ã®ãƒãƒƒãƒ•ã‚¡ã‚’å¤‰æ›´
    let bn = bufnr()
    let buflist = tabpagebuflist()
    call remove(buflist, index(buflist, bn))
    let tmpbn = buflist[0]
    let restwins = []

    for wn in range(1, winnr('$'))
      if winbufnr(wn) ==# bn
        call insert(restwins, wn)
        execute wn . 'windo' 'buffer' tmpbn
      endif
    endfor

    execute 'bwipeout' bn
    execute 'edit' filepath
    let bn = bufnr()

    for wn in restwins
      execute wn . 'windo' 'buffer' bn
    endfor
  else
    bwipeout
    execute 'edit' filepath
  endif

  if exists('l:view')
    call winrestview(view)
    normal! zv
  endif
endfunction "}}}

function! Mode() abort "{{{
  let mode = mode(1)

  let mode = substitute(mode, '\Cr', 'p', '')
  let mode = substitute(mode, '\C[SV]\zs', 'l', '')
  let mode = substitute(mode, "\\C\<C-v>", 'vr', '')
  let mode = substitute(mode, "\\C\<C-s>", 'sr', '')

  return toupper(mode[0]) . mode[1:]
endfunction "}}}
"}}}

" ã‚³ãƒãƒ³ãƒ‰ "{{{
cnoreabbrev <expr> w] Cmdwhen(':', 'w]', 'write')
cnoreabbrev <expr> new Cmdwhen(':', 'new', 'enew')
cnoreabbrev <expr> newtab Cmdwhen(':', 'newtab', 'tabnew')

" vimrcç­‰ã‚’é–‹ã "{{{
let s:vimrc = expand('<sfile>')
let s:gvimrc = expand('<sfile>:h') . '/.gvimrc'

command! -bar -nargs=0 Evimrc edit `=s:vimrc`
command! -bar -nargs=0 Egvimrc edit `=s:gvimrc`
command! -bar -nargs=0 Svimrc source `=s:vimrc`
cnoreabbrev <expr> ev Cmdwhen(':', 'ev', 'Evimrc')
cnoreabbrev <expr> evimrc Cmdwhen(':', 'evimrc', 'Evimrc')
cnoreabbrev <expr> egv Cmdwhen(':', 'egv', 'Egvimrc')
cnoreabbrev <expr> egvimrc Cmdwhen(':', 'egvimrc', 'Egvimrc')
cnoreabbrev <expr> sv Cmdwhen(':', 'sv', 'Svimrc')
cnoreabbrev <expr> svimrc Cmdwhen(':', 'svimrc', 'Svimrc')

if g:vimrc#is_gui
  command! -bar -nargs=0 Sgvimrc source `=s:gvimrc`
  cnoreabbrev <expr> sgv Cmdwhen(':', 'sgv', 'Sgvimrc')
  cnoreabbrev <expr> sgvimrc Cmdwhen(':', 'sgvimrc', 'Sgvimrc')
endif "}}}

" setglobal, autocmd, highlight ã®ãƒ©ãƒƒãƒ‘ãƒ¼ "{{{
command! -complete=event -nargs=* Autocmd autocmd Vimrc <args>
command! -bar -complete=highlight -nargs=*
    \ Highlight Autocmd ColorScheme * highlight <args>

if g:vimrc#is_starting
  command -complete=filetype -nargs=*
      \ AutocmdFT Autocmd VimEnter * Autocmd FileType <args>
  command -bar -complete=option -nargs=* SetG set <args>

  Autocmd VimEnter * command! -complete=filetype -nargs=*
      \   AutocmdFT Autocmd FileType <args>
  Autocmd VimEnter * command! -bar -complete=option -nargs=*
      \   SetG setglobal <args>
else
  command! -complete=filetype -nargs=* AutocmdFT Autocmd FileType <args>
  command! -bar -complete=option -nargs=* SetG setglobal <args>
endif

" syntax "{{{
AutocmdFT vim
    \ syntax keyword vimAutoCmd Autocmd skipwhite nextgroup=vimAutoEventList
AutocmdFT vim
    \ syntax keyword vimAutoCmd AutocmdFT nextgroup=vimAutoCmdSpace
AutocmdFT vim
    \ syntax keyword vimHighlight Highlight skipwhite nextgroup=vimHiBang,@vimHighlightCluster
AutocmdFT vim
    \ syntax keyword vimCommand contained SetG
AutocmdFT vim
    \ syntax region vimSet matchgroup=vimCommand start="\<\%(SetG\)\>" skip="\%(\\\\\)*\\.\n\@!" end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vim9Comment,vimSetString,vimSetMod
"}}}
"}}}

" ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã "{{{
command! -bar OpenSymbolicTarget call OpenSymbolicTarget()
"}}}

" Terminal "{{{
if g:vimrc#is_nvim
  command! -bar Terminal execute 'belowright 15new term://' . &shell
  cnoreabbrev <expr> terminal Cmdwhen(':', 'terminal', 'Terminal')
endif
"}}}

if !exists(':DiffOrig') "{{{
  command -bar -nargs=0 DiffOrig
      \ vertical new | setlocal buftype=nofile |
      \ read ++edit # | 0d_ | diffthis | wincmd p | diffthis
endif "}}}
"}}}

" ã‚ªãƒ—ã‚·ãƒ§ãƒ³ "{{{
" options "{{{
set ambiwidth=single
SetG autoindent cindent copyindent smartindent
SetG expandtab shiftwidth=2 softtabstop=2 tabstop=4
set shiftround smarttab
SetG autoread
set backspace=indent,eol,start whichwrap+=h,l
set backup backupskip+=*~,*.o
let &backupdir = g:vimrc#dotvim . '/.backup'
set browsedir=buffer
SetG complete-=u | set completeopt=menuone,longest,preview pumheight=8
set cmdheight=2
set confirm
SetG cursorline
set diffopt+=context:2,vertical
set display=lastline,uhex
set fillchars=fold:\ ,stl:\ ,stlnc:\ ,vert:\|
SetG foldenable foldmethod=marker foldtext=Foldtext()
SetG formatoptions+=Bjmr
set guicursor=a:block-Cursor
set helpheight=10 helplang=ja
set hidden
set history=1000
set hlsearch ignorecase incsearch smartcase | nohlsearch
SetG iminsert=0 imsearch=-1
set laststatus=2
setglobal statusline =\ %2{Mode()}%{&paste?'\ \ \|\ p':''}
setglobal statusline+=\ \|\ %n
setglobal statusline+=\ \|\ %{pathshorten(fnamemodify(expand('%:p'),':.:h').'/')}
setglobal statusline+=\ \|\ %{&filetype!=#'netrw'?expand('%:t'):''}
setglobal statusline+=\ %R%M%{&modified\|\|&readonly?'\ ':''}
if has('patch-8.2.2854')
  setglobal statusline+=%<%{%g:actual_curwin==#win_getid()?'%#StatusLineNC#':'%#Comment#'%}
else
  setglobal statusline+=%<%#StatusLineNC#
endif
if exists('+showcmdloc')
  setglobal statusline+=\ %S
endif
setglobal statusline+=%=%*
setglobal statusline+=\ %{(empty(&fileencoding)?&encoding:&fileencoding).'/'.&fileformat}
setglobal statusline+=\ \|\ %{empty(&filetype)?&buftype==#'terminal'?'terminal':'?':&filetype}
setglobal statusline+=\ \|\ %4P
setglobal statusline+=\ \|%4l:%2c\ %#StatusLineNC#
set lazyredraw
SetG list | set listchars=tab:>\ ,nbsp:%
SetG matchpairs+=<:> | set showmatch
SetG modeline
set mouse=a
SetG nrformats+=alpha
SetG number relativenumber
set pastetoggle=<F2>
set scrolloff=2
set sessionoptions+=localoptions,resize,slash,unix sessionoptions-=blank
set shortmess+=mrx shortmess-=t shortmess-=T
set showcmd
set showtabline=2
SetG signcolumn=auto
set splitbelow splitright
set nostartofline
set switchbuf=useopen,usetab
SetG synmaxcol=800
set timeout ttimeout timeoutlen=700 ttimeoutlen=50
set title
set undoreload=20000 | SetG undofile undolevels=800
let &undodir = g:vimrc#dotvim . '/.undo'
set updatecount=0 | SetG noswapfile
set updatetime=2000
set viewoptions+=localoptions,slash,unix
let &viewdir = g:vimrc#dotvim . '/.view'
set viminfo-=<50 viminfo+=<100
set virtualedit+=block
set wildcharm=<Tab> wildignore+=*~,*.o wildignorecase wildmenu wildmode=longest:full
set winaltkeys=yes

if exists('+ballooneval')
  set ballooneval
endif
if exists('+balloonevalterm')
  set balloonevalterm
endif
if exists('+breakindent')
  SetG breakindent breakindentopt=shift:2
endif
if exists('+fixendofline')
  SetG nofixendofline
endif
if exists('+packpath')
  let &packpath .= ',' . g:vimrc#dotvim . '/pack'
endif
if exists('+showcmdloc')
  set showcmdloc=statusline
endif
if exists('+termguicolors') && !g:vimrc#is_windows
  set termguicolors
endif
if exists('+termwinsize')
  SetG termwinsize=15*0
endif

if has('unnamedplus')
  set clipboard^=unnamedplus
else
  set clipboard^=unnamed
endif
if has('patch-7.4.314')
  set shortmess+=c
endif
if has('patch-8.1.360')
  set diffopt+=algorithm:histogram
endif
if has('patch-8.2.4325')
  set wildoptions=pum
endif

if g:vimrc#is_nvim
  set clipboard=
elseif g:vimrc#is_wsl
  set clipboard=exclude:.*
else
  set clipboard=exclude:console\|linux
endif
if g:vimrc#is_unix
  set shell=bash
endif "}}}

" ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚©ãƒ«ãƒ€ç­‰ã‚’ä½œæˆ "{{{
for s:d in filter(
    \ [&backup || &writebackup || &patchmode !=# '' ? 'backupdir' : '',
    \   &swapfile ? 'directory' : '', &undofile ? 'undodir' : '',
    \   exists('+loadplugins') && &loadplugins ? 'packpath' : '',
    \   'viewdir'], 'v:val !=# ""')
  if s:d != '' && !s:mkdir(eval('&' . s:d))
    execute 'set' s:d . '&'
  endif
endfor
unlet s:d "}}}

" $VIMRUNTIME ä»¥ä¸‹ã®ä¸è¦ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’èª­ã¿è¾¼ã¾ãªã„ "{{{
let g:loaded_2html_plugin = 1
let g:loaded_gzip = 1
let g:loaded_tar = 1
let g:loaded_tarPlugin = 1
let g:loaded_zip = 1
let g:loaded_zipPlugin = 1
let g:loaded_rrhelper = 1
let g:loaded_vimball = 1
let g:loaded_vimballPlugin = 1
let g:loaded_getscript = 1
let g:loaded_getscriptPlugin = 1
"}}}

" $VIMRUNTIMEä»¥ä¸‹ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®è¨­å®š "{{{
let g:netrw_clipboard = 0
let g:netrw_keepj = ""
let g:netrw_liststyle = 3
let g:netrw_sizestyle = "H"
let g:netrw_use_errorwindow = 2
let g:netrw_winsize = -15
let g:vim_indent_cont = shiftwidth()*2
"}}}
"}}}

" ã‚­ãƒ¼ãƒãƒƒãƒ— "{{{
map <Nul> <C-Space>
map! <Nul> <C-Space>

" minttyã ã‘?
" map <C-j> <S-CR>
" map! <C-j> <S-CR>

noremap - ^
noremap ^ $
sunmap -
sunmap ^

" nnoremap gi '[v']
nnoremap go gi

vnoremap za zo

noremap iq i'
noremap iQ i"
nunmap iq
nunmap iQ
sunmap iq
sunmap iQ

" ãƒãƒƒãƒã—ãŸæ–‡å­—åˆ—ã‚’é¸æŠ
" TODO: ãƒãƒƒãƒã—ãŸæ–‡å­—åˆ—å†…ã‹åˆ¤å®š
onoremap / //e<CR>

noremap j gj
noremap k gk
noremap gj j
noremap gk k
sunmap j
sunmap k
sunmap gj
sunmap gk

noremap c "_c
nnoremap C "_C
noremap D "_d
nnoremap DD "_dd
noremap x "_x
noremap X x
xnoremap p "_dP
sunmap c
ounmap c
sunmap D
ounmap D
sunmap x
ounmap x
sunmap X
ounmap X

noremap n nzzzv
noremap N Nzzzv
" nnoremap <silent> * :let stay_star_view = winsaveview()<cr>*:call winrestview(stay_star_view)<cr>
" vnoremap <silent> * :let stay_star_view = winsaveview()<cr>*:call winrestview(stay_star_view)<cr>
noremap * g*<C-o>
noremap # g#<C-o>
noremap g* *<C-o>
noremap g# #<C-o>
sunmap n
sunmap N
sunmap *
sunmap #
sunmap g*
sunmap g#

noremap <C-e> <C-e>j
noremap <C-y> <C-y>k
noremap <C-u> <C-u>zz
noremap <C-d> <C-d>zz
noremap <C-f> <C-f>zz
noremap <C-b> <C-b>zz
" noremap <ScrollWheelUp> 3<C-y>
" noremap <ScrollWheelDown> 3<C-e>

" inoremap <C-u> <C-p>
" cnoremap <C-u> <C-p>
cnoremap <C-g> <C-u>

nnoremap Y y$
noremap! jk <Esc>
nnoremap <Tab> <C-i>
nnoremap <S-Tab> <C-o>
" cnoremap <Esc><Esc> <C-c>

" noremap! <C-p> <Up>
" noremap! <C-l> <Down>
" inoremap <C-k> <Left>
" cnoremap <C-k> <Space><BS><Left>
" inoremap <C-@> <Right>
" cnoremap <C-@> <Space><BS><Right>

" inoremap <C-y> <C-o>^
" cnoremap <C-y> <Home>
" noremap! <C-b> <End>
" cnoremap <C-e> <C-y>

inoremap <BS> <C-g>u<BS>
inoremap <CR> <C-]><C-g>u<CR>

nnoremap gs :%s/
xnoremap gs :s/

noremap <F1> <Esc>:help<Space>
nnoremap <F1> :<C-u>help<Space>
inoremap <F1> <Esc>:help<Space>

nnoremap <CR> o<Esc>
nnoremap <expr> <S-CR> 'O<Esc>j' . v:count . 'k'
inoremap <C-CR> <C-o>o
nnoremap <C-Space> i<CR><Esc>
nnoremap <C-CR> i<CR><Esc>

inoremap <silent> <C-z> <C-o>:update<CR>
nnoremap <silent> <Space><Tab> :<C-u>nohlsearch<CR>

nnoremap <silent> <Space>tt :<C-u>tabnew<CR>
nnoremap <expr> gt <SID>delcount(v:count) .
    \ ((tabpagenr() + max([v:count - 1, 0])) % tabpagenr('$') + 1) . 'gt'

nnoremap <silent> <C-n> :<C-u><C-r>=v:count<CR>bnext<CR>
nnoremap <silent> <C-p> :<C-u><C-r>=v:count<CR>bprevious<CR>
nnoremap <silent> <Space>bn :<C-u><C-r>=v:count<CR>bnext<CR>
nnoremap <silent> <Space>bN :<C-u><C-r>=v:count<CR>bNext<CR>
nnoremap <silent> <Space>bp :<C-u><C-r>=v:count<CR>bprevious<CR>

nnoremap <silent> <Space>cn :<C-u><C-r>=v:count<CR>cnext<CR>
nnoremap <silent> <Space>cN :<C-u><C-r>=v:count<CR>cNext<CR>
nnoremap <silent> <Space>cp :<C-u><C-r>=v:count<CR>cprevious<CR>

nnoremap <silent> <Space>ln :<C-u><C-r>=v:count<CR>lnext<CR>
nnoremap <silent> <Space>lN :<C-u><C-r>=v:count<CR>lNext<CR>
nnoremap <silent> <Space>lp :<C-u><C-r>=v:count<CR>lprevious<CR>

nnoremap <silent> <Space>h
    \ :<C-u>echo map(synstack(line('.'),col('.')),'synIDattr(v:val,"name")')<CR>

let g:foldmethods = ['marker', 'indent', 'expr']
call add(g:foldmethods, g:foldmethods[0])
nnoremap <silent> <Space>sf
    \ :<C-u>setlocal foldmethod=<C-r>=g:foldmethods[index(g:foldmethods,&foldmethod)+1]<CR> foldmethod?<CR>zv

inoremap <Plug>(vimrc_cr) <CR>
inoremap <Plug>(vimrc_complete-select) <C-y>
imap <expr><silent> <CR> pumvisible() ? '<Plug>(vimrc_complete-select)' : '<Plug>(vimrc_cr)'
cnoremap <expr> <Tab> wildmenumode() ? '<C-n>' : '<Tab>'
inoremap <expr> <C-f> search('^\s*\%#', 'bcn', line('.')) > 0 ? '<C-f>' : '<C-x><C-f>'

tnoremap <ScrollWheelUp> <C-\><C-n>
tnoremap <ScrollWheelDown> <C-\><C-n>
"}}}

" ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ "{{{
set fileformats=unix,dos,mac
set fileencodings=utf-8

if g:vimrc#is_cygwin
  set fileencodings+=cp932,euc-jp
elseif g:vimrc#is_windows
  set fileencodings+=cp932
else
  set fileencodings+=euc-jp,sjis
endif

" http://www.kawaz.jp/pukiwiki/?vim (404)
" http://pcmania.jp/~moraz/howto/install.html#japanese (404)
" Kaoriya Vim 6 ã®vimrcã‹ã‚‰ï¼Ÿ (http://elpeo.jp/diary/20031113p01.html)
" ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¼¢å­—ã‚³ãƒ¼ãƒ‰è‡ªå‹•åˆ¤åˆ¥ã®ãŸã‚ã«å¿…è¦ (è¦iconv)
if has('iconv')
  set fileencodings-=euc-jp

  " iconvãŒeucJP-msã«å¯¾å¿œã—ã¦ã„ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯
  if iconv('\x87\x64\x87\x6a', 'cp932', 'eucjp-ms') ==# '\xad\xc5\xad\xcb'
    let s:enc_euc = 'eucjp-ms'
    let s:enc_jis = 'iso-2022-jp-3'
    " iconvãŒJISX0213ã«å¯¾å¿œã—ã¦ã„ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯
  elseif iconv('\x87\x64\x87\x6a', 'cp932', 'euc-jisx0213') ==# '\xad\xc5\xad\xcb'
    let s:enc_euc = 'euc-jisx0213'
    let s:enc_jis = 'iso-2022-jp-3'
  else
    let s:enc_euc = 'euc-jp'
    let s:enc_jis = 'iso-2022-jp'
  endif

  " fileencodingsã‚’æ§‹ç¯‰
  if &encoding ==# 'utf-8'
    set fileencodings-=cp932 fileencodings-=sjis
    let &fileencodings = s:enc_jis . ',' . s:enc_euc .
        \ (g:vimrc#is_windows ? ',cp932,' : ',sjis,') . &fileencodings
  else
    set fileencodings-=utf-8 fileencodings-=ucs-2le fileencodings-=ucs-2
    let &fileencodings .= ',' . s:enc_jis . ',utf-8,ucs-2le,ucs-2'

    if &encoding =~# '^\(euc-jp\|euc-jisx0213\|eucjp-ms\)$'
      set fileencodings-=euc-jp fileencodings-=euc-jisx0213 fileencodings-=eucjp-ms
      let &encoding = s:enc_euc
      let &g:fileencoding = s:enc_euc
    else
      let &fileencodings .= ',' . s:enc_euc
    endif
  endif

  unlet s:enc_euc
  unlet s:enc_jis
endif

" encodingã‚’fileencodingsã®æœ€å¾Œã«ç§»å‹•
execute 'set fileencodings-=' . &encoding
execute 'set fileencodings+=' . &encoding

" æ—¥æœ¬èªã‚’å«ã¾ãªã„å ´åˆã¯ fileencoding ã« encoding ã‚’ä½¿ã†ã‚ˆã†ã«ã™ã‚‹
Autocmd BufReadPost,FileReadPost,FilterReadPost *
    \ if &fileencoding=~#'iso-2022-jp' && search("[^\x01-\x7e]", 'n')==0 |
    \   let &fileencoding = &encoding | endif "}}}

" terminal "{{{
" https://ttssh2.osdn.jp/manual/4/ja/usage/tips/vim.html
if !g:vimrc#is_gui && &term !~# 'cygwin\|win32\|linux' " &term =~# 'xterm' &&
  " set t_Co=256

  " for RLogin "{{{
  if &term ==# 'rlogin-color' && !g:vimrc#is_nvim
    if g:vimrc#is_starting
      " true color
      let &t_8f = "\e[38:2:%lu:%lu:%lum"
      let &t_8b = "\e[48:2:%lu:%lu:%lum"
      " let &t_8u = ""

      " ç«¯æœ«ã¸æƒ…å ±ã‚’è¦æ±‚
      let &t_RF = "\e]10;?\x07"
      let &t_RB = "\e]11;?\x07"
      let &t_RV = "\e[>c"

      " ä¸‹ç·š
      " let &t_AU = ""
      " let &t_Ce = ""
      " let &t_Cs = ""

      " æ‰“ã¡æ¶ˆã—ç·š
      let &t_Ts = "\e[9m"
      let &t_Te = "\e[29m"

      " ã‚«ãƒ¼ã‚½ãƒ«
      let &t_RC = "\e[?12$p"
      let &t_VS = "\e[?12h"
      let &t_vs = "\e[?12l"
      " let &t_RS = ""
      " let &t_SC = "\e[<"
      " let &t_EC = "!q"
      let &t_SH = "\e[%p1%d q"

      " ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º
      let &t_WS = "\e[8;%p1%d;%p2%dt"

      " ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¿ã‚¤ãƒˆãƒ«
      let &t_ST = "\e[22;0t"
      let &t_RT = "\e[23;0t"

      " ã‚¢ã‚¤ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
      let &t_IS = "\e]1;"
      let &t_IE = "\x07"
      let &t_Si = "\e[22;0t"
      let &t_Ri = "\e[23;0t"

      " blacketed paste mode
      let &t_BE = "\e[?2004h"
      let &t_BD = "\e[?2004l"
      let &t_PS = "\e[200~"
      let &t_PE = "\e[201~"

      " ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
      let &t_fe = "\e[?1004h"
      let &t_fd = "\e[?1004l"
    endif

    execute "set <FocusGained>=\e[I"
    execute "set <FocusLost>=\e[O"
  " endif

  " modifyOtherKeys "{{{
  " if GetXTVersion() =~# '^RLogin' " å¿œç­”ãŒã‚­ãƒ¼å…¥åŠ›æ‰±ã„ã«ãªã£ã¦ã—ã¾ã†ã®ã§ç„¡åŠ¹åŒ–
    " modifyCursorKeysã¨modifyStringKeysã‚‚æœ‰åŠ¹ã«ã™ã‚‹
    if g:vimrc#is_starting
      " æœ‰åŠ¹ã«ã™ã‚‹ã¨ä¸€éƒ¨ã®ã‚­ãƒ¼(DD, <C-r>")ã§å•é¡ŒãŒã‚ã‚‹ã®ã§modifyOtherKeysä»¥å¤–ã‚’ä¸€æ—¦ç„¡åŠ¹åŒ–
      " let &t_TI = "\e[>1;2m\e[>4;2m\e[>5;2m"
      " let &t_TE = "\e[>1;m\e[>4;m\e[>5;m"
      let &t_TI = "\e[>4;2m"
      let &t_TE = "\e[>4;m"
    endif

    " Seen modifyOtherKeys: true ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã‚­ãƒ¼ã‚³ãƒ¼ãƒ‰ã«å¯¾ã—ã¦ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹
    let s:modifers = [
        \   {'name': 'S', 'code': 2},
        \   {'name': 'A', 'code': 3},
        \   {'name': 'A-S', 'code': 4},
        \   {'name': 'C', 'code': 5},
        \   {'name': 'C-S', 'code': 6},
        \   {'name': 'A-C', 'code': 7},
        \   {'name': 'A-C-S', 'code': 8}
        \ ]
    let s:keys = [
        \   {'name': 'BS', 'code': 8},
        \   {'name': 'Tab', 'code': 9},
        \   {'name': 'CR', 'code': 13}
        \ ]

    for s:modifer in s:modifers
      for s:key in s:keys
        execute 'map <special>'
            \ printf('<Esc>[27;%d;%d~', s:modifer['code'], s:key['code'])
            \ printf('<%s-%s>', s:modifer['name'], s:key['name'])
        execute 'map! <special>'
            \ printf('<Esc>[27;%d;%d~', s:modifer['code'], s:key['code'])
            \ printf('<%s-%s>', s:modifer['name'], s:key['name'])
      endfor
    endfor
    unlet s:modifers s:modifer s:keys s:key

    cnoremap <special><expr> <S-Tab> wildmenumode() ? '<C-p>' : '<Tab>'
  endif "}}}
  "}}}

  " Shift-Insertã®ãƒšãƒ¼ã‚¹ãƒˆæ™‚ã«è‡ªå‹•ã§pastetoggle "{{{
  " https://qiita.com/ringo/items/bb9cf61a3ccfe6183c7b
  " https://qiita.com/kefir_/items/415a30930a80b9b42adb
  if !has("patch-8.0.238") && !g:vimrc#is_nvim
    if g:vimrc#is_starting
      if has("patch-8.0.210")
          set t_BE=
      endif

      let &t_ti .= "\e[?2004h"
      " let &t_te .= "\e[?2004l"
      let &t_te = "\e[?2004l" . &t_te
      let &pastetoggle = "\e[201~"
    endif

    function! s:xTermPasteBegin(ret) abort
      set paste
      return a:ret
    endfunction

    " noremap <special> <expr> <Esc>[200~ XTermPasteBegin('0i')
    noremap <special> <expr> <Esc>[200~ <SID>xTermPasteBegin('i')
    inoremap <special> <expr> <Esc>[200~ <SID>xTermPasteBegin('')
    cnoremap <special> <Esc>[200~ <nop>
    cnoremap <special> <Esc>[201~ <nop>

    map <F2> <Esc>[201~
    imap <F2> <Esc>[201~
  endif "}}}

  " OSC52ã§ã®ã‚³ãƒ”ãƒ¼ "{{{
  function s:paste64(text) abort
    let str = join(systemlist('base64 --wrap=0', a:text), '')

    let seq = printf("\e]52;;%s\e\\", str)
    if g:vimrc#is_nvim
      let blob = [seq]
    else
      let blob = list2blob(str2list(seq))
    endif

    call writefile(blob, '/dev/tty', 'a')

    if g:vimrc#is_nvim
      redraw!
    endif
  endfunction

  nnoremap <silent> <Space>y :<C-u>call <SID>paste64(@")<CR>
  "}}}

  " æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ã‚’å‡ºã‚‹ã¨ãã«IMEã‚’è‡ªå‹•ã§åˆ‡ã‚‹ "{{{
  " https://qiita.com/U25CE/items/0b40662a22162907efae#%E7%AB%AF%E6%9C%AB%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3
  if g:vimrc#is_starting && !g:vimrc#is_nvim
    let &t_SI .= "\e[<r"
    let &t_EI .= "\e[<s\e[<0t"
    let &t_te .= "\e[<0\e[<s"
  endif "}}}

  " æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ã§ã®ESCã‚­ãƒ¼ã®å¾…ã¡ã‚’ãªãã™ "{{{
  inoremap <special> <Esc>O[ <Esc>
  inoremap <special> <C-V><Esc>O[ <C-V><Esc>
  inoremap <special> <C-r><Esc>O[ <Nop>
  noremap <special> r<Esc>O[ <Nop>
  noremap <special> r<C-v><Esc>O[ r<Esc>

  if g:vimrc#is_starting && !g:vimrc#is_nvim
    let &t_SI .= "\e[?7727h"
    let &t_EI .= "\e[?7727l"
  endif "}}}

  " ç¸¦åˆ†å‰²æ™‚ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®é«˜é€ŸåŒ– "{{{
  " https://qiita.com/kefir_/items/c725731d33de4d8fb096
  if 0 && !g:vimrc#is_nvim
    set nottyfast
    function! s:enableVsplitMode() abort "{{{
      " enable origin mode and left/right margins
      let &t_CS = 'y'
      let &t_CV = "\e[%i%p1%d;%p2%ds"
      let &t_te = "\e[?6;69l" . &t_te
      " let &t_te = "\e[?6;69l\e[999H" . &t_te
      " let &t_te = "\e7\e[?6;69l\e8" . &t_te
      " let &t_te .= "\e[?6;69l"
      " let &t_te .= "\e[?6;69l\e[999H"
      " let &t_te .= "\e7\e[?6;69l\e8"
      let &t_ti .= "\e[?6;69h"
      "   call writefile(["\e[?6h\e[?69h"], '/dev/tty', 'a')
      call writefile(["\e[?6;69h"], '/dev/tty', 'a')
    endfunction "}}}

    " old vim does not ignore CPR
    " map <special> <Esc>[3;9R <Nop>

    " new vim can't handle CPR with direct mapping
    " map <expr> [3;3R <SID>enableVsplitMode()
    " set t_F9=[3;3R
    map <Esc>[3;3R <t_F9>
    map <expr> <t_F9> <SID>enableVsplitMode()

    if g:vimrc#is_starting
      let &t_RV .= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
    endif
  endif "}}}

  " Vimçµ‚äº†æ™‚ã«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¿ã‚¤ãƒˆãƒ«ã‚’èµ·å‹•å‰ã®çŠ¶æ…‹ã«æˆ»ã™ "{{{
  if !has("patch-8.1.0253") && g:vimrc#is_starting && !g:vimrc#is_nvim
    let &t_ti .= "\e[22;0t"
    let &t_te .= "\e[23;0t"
  endif "}}}

  " ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾— "{{{
  " å¿œç­”ãŒ DCS (ESC P) > | VERSION ST (ESC \)ã§è¿”ã£ã¦ãã‚‹ã®ã§ã©ã†ã«ã‹ã—ã¦å–å¾—
  " Neovimã ã¨å¿œç­”ãŒå–ã‚Œãªã„?
  function! GetXTVersion() abort
    " unmap <Esc>P><Bar>
    " let &t_ti = substitute(&t_ti, "\e[>0q", '', '')

    if exists('g:xtversion')
      return g:xtversion
    endif

    call writefile(list2blob(str2list("\e[>0q")), '/dev/tty', 'a')
    sleep 200m
    call s:parse_response()

    return g:xtversion
  endfunction

  function! s:parse_response() abort
    let res = []
    let i = 1
    while 1
      let c = getchar(0)
      " echomsg printf("%d, %s", i, string(c))
      if !c
        break
      elseif i ==# 1 && c ==# char2nr("\e")
        let i += 1
      elseif i ==# 2 && c ==# char2nr('P')
        let i += 1
      elseif i ==# 3 && c ==# char2nr('>')
        let i += 1
      elseif i ==# 4 && c ==# char2nr('|')
        let i += 1
      elseif i ==# 5
        if c ==# char2nr("\e")
          let i += 1
        else
          let res += [c]
        endif
      elseif i ==# 6 && c ==# char2nr('\')
        break
      else
        echomsg 'wrong response'
        while getchar(0) | endwhile
        break
      endif
    endwhile

    let g:xtversion = list2str(res)
  endfunction

  " if g:vimrc#is_starting && !g:vimrc#is_nvim
    " nnoremap <special><expr> <Esc>P><Bar> GetXTVersion()
    " let &t_ti .= "\e[>0q"
  " endif "}}}
endif "}}}

" ColorScheme "{{{
set background=dark
Highlight ColorColumn ctermbg=233 guibg=#181818
" Highlight Folded ctermfg=247 ctermbg=234 guibg=#303030

Highlight CursorLineNr ctermbg=NONE guibg=NONE
" Highlight LineNr ctermfg=darkgreen guifg=#00c000
Highlight SignColumn ctermbg=NONE guibg=NONE
" Highlight StatusLineNC ctermfg=235

" Highlight TabLineFill ctermfg=236

" Highlight Pmenu ctermfg=black ctermbg=lightgray guifg=black guibg=lightgray
" Highlight PmenuSbar ctermfg=black guifg=black
" Highlight PmenuSel ctermfg=yellow ctermbg=darkblue guifg=yellow guibg=blue
" Highlight PmenuThumb ctermfg=darkblue guifg=blue

" Highlight DiffChange ctermbg=25 guibg=#004060
" Highlight DiffText ctermbg=18 guibg=#000080
Highlight DiffAdd guifg=NONE
Highlight DiffChange guifg=NONE
Highlight DiffDelete guifg=NONE
Highlight DiffText guifg=NONE

" ã‚³ãƒ¡ãƒ³ãƒˆã®ãƒã‚¤ãƒ©ã‚¤ãƒˆãŒãŠã‹ã—ã„ã®ã§ä»¥å‰ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’é©ç”¨
" https://github.com/vim/vim/issues/11307
if has('patch-9.0.652')
  AutocmdFT vim syntax match vimLineComment +^[ \t:]*".*$+ contains=@vimCommentGroup,vimCommentString,vimCommentTitle
endif
"}}}

" autocmd "{{{
" ã‚«ãƒ¬ãƒ³ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã¿ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’å¼·èª¿ "{{{
Autocmd WinLeave * setlocal nocursorline
Autocmd WinEnter,BufWinEnter * setlocal cursorline
"}}}

" ä¿å­˜ã—ãŸã¨ãã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã¸ç§»å‹• "{{{
Autocmd BufReadPost ?*
    \ if line("'\"") > 0 && line ("'\"") <= line('$') |
    \   execute "normal! g'\"zv" |
    \ endif
"}}}

" ç”»é¢ã®81æ¡ç›®ã«colorcolumnã‚’è¡¨ç¤º "{{{
Autocmd BufEnter,BufWinEnter,ColorScheme,FileType *
    \ let &colorcolumn = 81 - s:winleftpad()
Autocmd OptionSet foldcolumn,number,numberwidth,relativenumber,signcolumn
    \ let &colorcolumn = 81 - s:winleftpad()
"}}}

" ãã®ä»– "{{{
" Autocmd QuickfixCmdPost make call QfMakeConv(&fileencoding, &encoding)
" if g:vimrc#is_windows
"   Autocmd QuickfixCmdPost make call QfMakeConv('utf-8', 'cp932')
" else
"   Autocmd QuickfixCmdPost make call QfMakeConv('cp932', 'utf-8')
" endif

AutocmdFT * setlocal formatoptions-=o
" AutocmdFT * if &commentstring !~# '^ ' |
"    \ let &commentstring = ' ' . &commentstring | endif
AutocmdFT c setlocal omnifunc=ccomplete#Complete
AutocmdFT * if &omnifunc ==# '' |
    \ setlocal omnifunc=syntaxcomplete#Complete | endif
AutocmdFT git,help,netrw,qf
    \ noremap <buffer><silent> q :<C-u>bwipeout<CR>
AutocmdFT qf
    \ nnoremap <buffer><silent> <CR> :<C-u>execute 'cc!' line('.')<CR>
Autocmd CmdwinEnter * nnoremap <buffer><silent> q :<C-u>q<CR>
AutocmdFT vim,help setlocal keywordprg=:help
Autocmd BufNewFile *.bat setlocal fileencoding=cp932 fileformat=dos
execute 'Autocmd BufReadPre' &backupskip 'setlocal noundofile'
" Autocmd CmdlineChanged : if !wildmenumode() && len(getcompletion(getcmdline(), 'cmdline')) > 1 | call feedkeys("\<Tab>") | endif
if g:vimrc#is_nvim
  Autocmd TermOpen * setlocal nobuflisted nonumber norelativenumber winfixheight
  Autocmd TermOpen * nnoremap <buffer><silent><expr> q term_getstatus(bufnr()) =~# 'finished' ? ':<C-u>q<CR>' : ''
  Autocmd TermOpen * startinsert
  Autocmd TermClose * if !v:event.status | execute 'bdelete! ' . expand('<abuf>') | endif
elseif has('terminal')
  if exists('##TerminalWinOpen')
    Autocmd TerminalWinOpen * setlocal nobuflisted nonumber norelativenumber winfixheight
    Autocmd TerminalWinOpen * nnoremap <buffer><silent><expr> q term_getstatus(bufnr()) =~# 'finished' ? ':<C-u>q<CR>' : ''
  else
    Autocmd TerminalOpen * setlocal nobuflisted nonumber norelativenumber winfixheight
    Autocmd TerminalOpen * nnoremap <buffer><silent><expr> q term_getstatus(bufnr()) =~# 'finished' ? ':<C-u>q<CR>' : ''
  endif
endif
Autocmd BufWinEnter,ColorScheme,FileType * call HighlightTrailingSpace()
AutocmdFT diff setlocal vartabstop=9,8

augroup Vimrc_bin
  autocmd!
  autocmd BufReadPre *.bin,*.exe,*.dll setlocal binary
  autocmd BufReadPost *
      \ if &binary |
      \   execute 'silent %!xxd -g 1' |
      \   setlocal filetype=xxd noendofline |
      \   execute 'Autocmd BufWritePre <buffer=abuf> %!xxd -r' |
      \   execute 'Autocmd BufWritePost <buffer=abuf> silent %!xxd -g 1' |
      \   execute 'Autocmd BufWritePost <buffer=abuf> setlocal nomodified' |
      \ endif
augroup END
"}}}
"}}}

" plugin "{{{
if has('patch-7.4.1649')
  packadd! matchit
else
  runtime macros/matchit.vim
endif

" ç”»é¢åˆ‡ã‚Šæ›¿ãˆå‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é…å»¶ã•ã›ã‚‹
redir => s:msg
silent execute 'source' g:vimrc#dotvim . '/dein.vim'
silent runtime! plugin/**/*.vim
redir END
Autocmd VimEnter *
    \ for line in split(s:msg, "\n") |
    \   echomsg line |
    \ endfor
"}}}

Autocmd VimEnter * doautocmd Vimrc FileType

if get(g:, 'colors_name', '') ==# ''
  colorscheme desert
endif

filetype plugin indent on
syntax on

if !g:vimrc#is_starting
  doautocmd Vimrc VimEnter
endif
