" don't load when -eval(vim-tiny, vim-small)
if 0 | endif

" Initialize "{{{
if &compatible | set compatible! | endif

if !exists('g:vimrc#is_starting')
  let g:vimrc#is_windows = has('win32')
  let g:vimrc#is_cygwin = has('win32unix')
  let g:vimrc#is_unix = has('unix') && !g:vimrc#is_cygwin
  let g:vimrc#is_wsl = g:vimrc#is_unix && system('uname -r') =~? 'microsoft'
  let g:vimrc#is_nvim = has('nvim')
  if g:vimrc#is_nvim
    if empty(nvim_list_uis())
      " UI connected later are regarded as GUI
      let g:vimrc#is_gui = 1
    elseif nvim_list_uis()[0].chan ==# 0
      " embed
      let g:vimrc#is_gui = 0
    else
      " UI process is separated even in CUI since nvim v0.9.0
      let s:ui_name = nvim_get_proc(nvim_get_proc(getpid()).ppid).name
      let g:vimrc#is_gui = s:ui_name !~# '^nvim\(\.exe\)\?$'
      unlet s:ui_name
      " let g:vimrc#is_gui = !empty(nvim_get_chan_info(nvim_list_uis()[0].chan).client)
    endif
  else
    let g:vimrc#is_gui = has('gui_running')
  endif
  let g:vimrc#is_starting = 1
  let g:vimrc#dotvim = expand('~/.vim')
endif

let g:mapleader = ' '

if !g:vimrc#is_nvim
  scriptversion 4
endif

augroup Vimrc
  autocmd!
  autocmd VimEnter * ++once let g:vimrc#is_starting = 0
augroup END "}}}

" use Vim with singleton "{{{
if has('clientserver') && !exists('g:loaded_editexisting')
  let g:loaded_editexisting = 1
  packadd! editexisting
endif "}}}

" print startup time "{{{
" https://gist.github.com/thinca/1518874#file-vimrc-L20
if g:vimrc#is_starting && has('reltime')
  let s:startuptime = reltime()
  " :redraw hides intro message
  augroup vimrc-startuptime
    autocmd! VimEnter * ++once
        \ let s:startuptime = reltime(s:startuptime) |
        \ echomsg 'startuptime: ' .. reltimestr(s:startuptime) |
        \ unlet s:startuptime | autocmd! vimrc-startuptime
  augroup END
endif "}}}

" encoding "{{{
" if &encoding !=# 'utf-8'
if &term ==# 'win32' " command prompt
  set encoding=cp932
else
  set encoding=utf-8
endif

if g:vimrc#is_windows
  set termencoding=cp932
  setglobal fileencoding=cp932
else
  set termencoding=utf-8
  setglobal fileencoding=utf-8
endif

" setglobal fileencoding=japan
" endif

scriptencoding utf-8 "}}}

" functions "{{{
function! s:mkdir(path) abort "{{{
  " return: ディレクトリを読み込めない(作成できない)とき0, それ以外は1
  if a:path =~# '^.\{-}://' " Non local file, ignore
    return 0
  endif

  for p in split(a:path, ',')
    if !isdirectory(p)
      if !filereadable(p) && !filewritable(p)
        call mkdir(p, 'p')
        return 1
      endif
    else
      return 1
    endif
  endfor

  echoerr a:path .. ' should be directory and readable.'
  return 0
endfunction "}}}

" quickfixリストの文字化け回避 "{{{
function! QfMakeConv(fenc, enc) abort
  let qflist = getqflist()
  for i in qflist
    let i.text = iconv(i.text, a:fenc, a:enc)
  endfor
  call setqflist(qflist, 'r')
endfunction "}}}

" マップ時のv:countを<Esc>を使わずに削除 "{{{
" ex. noremap <expr> j <SID>delcount(v:count) . 'gj'
function! s:delcount(count) abort
  return !a:count ? '' : repeat("\<Del>", strlen(string(a:count)))
endfunction "}}}

" 自動で生成されるバッファか判定 "{{{
let g:vimrc#generate_filetypes = ['git', 'netrw', 'qf']

" a:1 - バッファ番号 (0か省略されたとき現在のバッファに対して判定)
function! IgnoreBuffer(bn = 0) abort
  let bn = a:bn
  if bn ==# 0
    let bn = bufnr()
  endif

  let bh = getbufvar(bn, '&bufhidden')
  let bname = fnamemodify(bufname(bn), ':t')
  let bt = getbufvar(bn, '&buftype')
  let fts = getbufvar(bn, '&filetype')
  let wt = exists('*win_gettype') ? win_gettype(bufwinnr(bn)) : ''

  if !bufexists(bn)
    return 1
  elseif !buflisted(bn)
    return 1
  elseif !empty(bt)
    return 1
  elseif !(empty(bh) || bh ==# 'hide')
    return 1
  elseif !(wt ==# '' || wt ==# 'unknown')
    return 1
  endif

  for ft in split(fts, '\.')
    if index(g:vimrc#generate_filetypes, ft) !=# -1
      return 1
    elseif ft ==# 'help' && !&modifiable
      return 1
    endif
  endfor

  return IsCommandLineWindow(bn)
endfunction "}}}

" 行末の空白をハイライト "{{{
function! s:highlight_trailing_space() abort
  if IgnoreBuffer()
    if get(w:, 'spaceid', 0)
      call matchdelete(w:spaceid)
      unlet w:spaceid
    endif
  else
    highlight TrailingWhiteSpace ctermbg=darkred guibg=#ff0000
    if !get(w:, 'spaceid', 0)
      let w:spaceid = matchadd('TrailingWhiteSpace', '\s\+$', 11)
    endif
  endif
endfunction "}}}

" 指定範囲の空行を削除 "{{{
function! s:delemptyline(start, last) abort
  " return: 削除した行の数
  let save_cursor = getcurpos()

  let n = 0 | let end = a:last
  call cursor(a:start, 1)
  while 1
    let l = search('^$', 'c', end)
    if l <= 0 | break | endif

    execute l .. 'delete' '_'
    let n += 1 | let end -= 1
  endwhile

  call setpos('.', save_cursor)
  return n
endfunction "}}}

" バックスラッシュを消して結合(J) "{{{
function! s:J() range
  set operatorfunc=Concat
  return 'g@' .. max([a:lastline - a:firstline - 1, 1]) .. 'j'
endfunction

function! Concat(type) abort
  let js_save = &joinspaces
  let sel_save = &selection
  set selection=inclusive

  let startline = line("'[")
  let endline = line("']")

  if startline ==# endline
    let endline += 1
  endif

  let endline -= s:delemptyline(startline, endline)
  if startline < endline
    let lines = getline(startline + 1, endline)

    " ソースコード中では結合時に空白を入れない
    if &filetype !~# '\v(\.|^)(text|markdown)(\.|$)'
      let synname = synIDattr(synID(startline, col('$') - 1, 1), "name")
      if synname !~# '\v(Comment|String)$'
        set nojoinspaces
      else
        " call map(lines, { _, v -> substitute(v, '^\s*' .. substitute(&commentstring, '^\s*\|%s', '', 'g'), '', '') })
      endif
    endif

    if &filetype =~# '\v(\.|^)vim(\.|$)'
      " 行継続を削除
      call map(lines, { _, v -> substitute(v, '^\s*\\', '', '') })

      " foldmarkerのコメント文字は残す
      let [foldstart, foldend] = split(&foldmarker, ',')
      call map(lines, { _, v -> substitute(v, '\ze"\s*' .. foldstart, '" ', '') }) " not vim9script
      let lines = [getline(startline)] + lines
    else
      let lastline = lines[-1]
      let lines = [getline(startline)] + lines[:-2]

      " 行継続を削除
      call map(lines, { _, v -> substitute(v, '\\$', '', '') })

      let lines += [lastline]
    endif

    call setline(startline, lines)
    execute 'join' endline - startline + 1
  endif

  let &joinspaces = js_save
  let &selection = sel_save
endfunction

noremap <expr> J <SID>J()
noremap <Leader>J J
sunmap J
ounmap J
sunmap <Leader>J
ounmap <Leader>J

nnoremap <silent> <Leader><Leader>J :<C-u>set operatorfunc=Concat<CR>g@
nnoremap <silent> <Leader><Leader>JJ :<C-u>set operatorfunc=Concat<CR>g@g@
"}}}

" ウィンドウの左側の余白の幅 "{{{
function! s:winleftpad() abort
  if has('patch-8.2.3627') || has('nvim-0.6.0')
    return getwininfo(win_getid())[0]['textoff']
  endif

  if &number
    let lnrwidth = max([strlen(string(line('$'))) + 1, &numberwidth])
  elseif &relativenumber
    let lnrwidth = max([strlen(string(winheight('.'))) + 1, &numberwidth])
  else
    let lnrwidth = 0
  endif

  if &signcolumn ==# 'yes'
    let signwidth = 2
  elseif &signcolumn ==# 'no'
    let signwidth = 0
  elseif &signcolumn ==# 'number' && &number
    let signwidth = 0
  else
    " [#{ signs: [...], bufnr: 2 }]
    let signs = sign_getplaced(bufname(), #{ group: '*' })
    if empty(signs[0]['signs'])
      let signwidth = 0
    else
      let signwidth = 2
    endif
  endif

  return lnrwidth + signwidth + &foldcolumn
endfunction "}}}

function! Foldtext() abort "{{{
  " function! Foldtext() abort                                    42 [2]
  let comment = split(substitute(&commentstring, '\s', '', 'g'), '%s')
  let commentstart = len(comment) < 1 ? '' : comment[0]
  let commentend = len(comment) < 2 ? '' : comment[1]

  let left = getline(v:foldstart)
  let marker = strpart(&foldmarker, 0, stridx(&foldmarker, ',')) .. '\d\*'

  " (コメント用の文字も含めて) マーカーを削除
  let pattern = printf('\V\s\*\(%s\)\?\s\*%s\s\*\(%s\|\.\*\$\)', commentstart, marker, commentend)
  let left = substitute(left, pattern, '', '')

  " コメント行の場合、コメント文字列のみにする
  let pattern = printf('\V\^\s\*\zs\(%s\)\?\s\*', commentstart)
  let left = substitute(left, pattern, '', '')

  " タブ文字を同じ幅のスペースに変換 (vartabstopには未対応)
  let left = substitute(left, '\t', repeat(' ', &tabstop), 'g')
  let leftlen = strwidth(left)

  let foldlinecount = foldclosedend(v:foldstart) - foldclosed(v:foldstart) + 1
  let right = printf(' %d [%d] ', foldlinecount, v:foldlevel)
  let rightlen = len(right)

  let linelen = winwidth('.') - s:winleftpad()

  " 表示する文字列が収まらないときに後ろの文字を畳む
  if leftlen + rightlen > linelen
    let leftlen = linelen - rightlen - 3
    while strwidth(left) > leftlen
      let left = strcharpart(left, 0, strchars(left) - 1)
    endwhile

    let left = left .. '...'
    let leftlen = strwidth(left)
  endif

  let fill = repeat(' ', linelen - (leftlen + rightlen))

  return left .. fill .. right
endfunction "}}}

" cmapやcabbrev用 "{{{
function! Cmdwhen(mode, lhs, rhs) abort
  if getcmdtype() ==# a:mode
    return a:rhs
  else
    return a:lhs
  endif
endfunction "}}}

function! OpenSymbolicTarget() abort "{{{
  let filepath = resolve(expand('%:p'))

  " Windowsではgetftype()からlinkが返らない
  " Vim 8.1.894, Neovim 0.5.0より前だとresolve()でのパス解決もWindowsでは動かない
  if filepath ==# expand('%:p')
    echohl Error
    echo 'not symbolic link'
    echohl None

    return
  endif

  " バッファを開いてからカーソルを動かしていないときはカーソル位置を保存しない
  if getpos('.') !=# getpos("'\"")
    " とりあえずカレントウィンドウのみ
    let view = winsaveview()
  endif

  let bn = bufnr()
  let restwins = BDeleteSaveWindow(bn)
  unlet restwins[index(restwins, win_getid())]

  " 完全に削除しないとリンク元のファイルが開かれる
  execute 'bwipeout' bn
  execute 'edit' filepath
  let bn = bufnr()

  for wn in restwins
    execute wn .. 'windo' 'buffer' bn
  endfor

  if exists('l:view')
    call winrestview(view)
    normal! zv
  endif
endfunction "}}}

function! Mode() abort "{{{
  let mode = mode(1)

  let mode = substitute(mode, '\Cr', 'p', '')
  let mode = substitute(mode, '\C[SV]\zs', 'l', '')
  let mode = substitute(mode, "\\C\<C-v>", 'vr', '')
  let mode = substitute(mode, "\\C\<C-s>", 'sr', '')

  return toupper(mode[0]) .. mode[1:]
endfunction "}}}

" 画面の81桁目にcolorcolumnを表示 "{{{
function! s:set_colorcolumn() abort
  if IgnoreBuffer()
    setlocal colorcolumn&
  else
    " TODO: もとの値があるときによしなにしたい
    let &l:colorcolumn = 81 - s:winleftpad()
  endif
endfunction "}}}

function! Highlights() abort "{{{
  call s:highlight_trailing_space()
  call s:set_colorcolumn()
endfunction "}}}

function! IsCommandLineWindow(bn = 0) abort "{{{
  let bn = a:bn
  if bn ==# 0
    let bn = bufnr()
  endif

  if exists('*win_gettype')
    return win_gettype(bufwinnr(bn)) ==# 'command'
  endif

  return !empty(getcmdwintype())
endfunction "}}}

function! BDeleteSaveWindow(bn) abort "{{{
  " 対象のバッファを表示しているウィンドウで別のバッファにしてからbdelete
  " 対象のバッファを表示していたウィンドウのIDをリストで返す
  " ※バッファが一つしかない場合はウィンドウを一つにする

  " typename(): 8.2.2339
  if type(a:bn) ==# v:t_number && a:bn <= 0
    return []
  endif

  if !empty(getcmdwintype())
    echohl Error
    echo 'Not works in command-line window'
    echohl None

    return []
  endif

  if getbufvar(a:bn, '&modified')
    " バッファ削除時のプロンプトが<silent>なマッピングで表示されないので回避
    return []
  endif

  let save_bh = getbufvar(a:bn, '&bufhidden')
  if save_bh !=# 'wipe'
    call setbufvar(a:bn, '&bufhidden', 'delete')
  endif

  let buflist = []
  for tn in range(tabpagenr('$'))
    call extend(buflist, tabpagebuflist(tn + 1))
  endfor

  let listed_bufs = []
  for b in filter(range(1, bufnr('$')), { _, b -> bufexists(b) })
    if b ==# a:bn || !IgnoreBuffer(b)
      call add(listed_bufs, b)
    endif
  endfor

  if len(listed_bufs) < 2
    execute 'bdelete' a:bn
    return [win_getid()]
    " confirm qall
  endif

  " 他に表示できるバッファがあるときに無名バッファを除外
  if len(filter(copy(listed_bufs), { _, b -> !empty(bufname(b)) })) >= 2
    let listed_bufs = filter(listed_bufs, { _, b -> !empty(bufname(b)) })
  endif

  " 対象の一つ後か前のバッファに切り替える
  call add(listed_bufs, listed_bufs[-2])
  let alt_bn = listed_bufs[index(listed_bufs, a:bn) + 1]

  let restwins = win_findbuf(a:bn)
  for wid in restwins
    call win_execute(wid, 'let tmp_bn = bufnr("#")')
    if tmp_bn < 0 || index(listed_bufs, tmp_bn) < 0 || !IgnoreBuffer(tmp_bn)
      let tmp_bn = alt_bn
    endif

    call win_execute(wid, 'buffer ' .. tmp_bn)
  endfor

  if buflisted(a:bn)
    execute 'bdelete' a:bn
  endif
  call setbufvar(a:bn, '&bufhidden', save_bh)

  return restwins
endfunction "}}}
"}}}

" コマンド "{{{
cnoreabbrev <expr> w] Cmdwhen(':', 'w]', 'write')
cnoreabbrev <expr> new Cmdwhen(':', 'new', 'enew')
cnoreabbrev <expr> newtab Cmdwhen(':', 'newtab', 'tab split')
cnoreabbrev <expr> es Cmdwhen(':', 'es', 'argadd')

" vimrc, gvimrcを開く "{{{
let s:vimrc = expand('<sfile>')
let s:gvimrc = expand('<sfile>:h') .. '/.gvimrc'

execute 'command! -bar -nargs=0 Evimrc edit' resolve(s:vimrc)
execute 'command! -bar -nargs=0 Egvimrc edit' resolve(s:gvimrc)
execute 'command! -bar -nargs=0 Svimrc source' s:vimrc
cnoreabbrev <expr> ev Cmdwhen(':', 'ev', 'Evimrc')
cnoreabbrev <expr> evimrc Cmdwhen(':', 'evimrc', 'Evimrc')
cnoreabbrev <expr> egv Cmdwhen(':', 'egv', 'Egvimrc')
cnoreabbrev <expr> egvimrc Cmdwhen(':', 'egvimrc', 'Egvimrc')
cnoreabbrev <expr> sv Cmdwhen(':', 'sv', 'Svimrc')
cnoreabbrev <expr> svimrc Cmdwhen(':', 'svimrc', 'Svimrc')

if g:vimrc#is_gui
  execute 'command! -bar -nargs=0 Sgvimrc source' s:gvimrc
  cnoreabbrev <expr> sgv Cmdwhen(':', 'sgv', 'Sgvimrc')
  cnoreabbrev <expr> sgvimrc Cmdwhen(':', 'sgvimrc', 'Sgvimrc')
endif

unlet s:vimrc s:gvimrc
"}}}

" setglobal, autocmd, highlight のラッパー "{{{
command! -complete=event -nargs=* Autocmd autocmd Vimrc <args>
command! -bar -complete=highlight -nargs=*
    \ Highlight Autocmd ColorScheme * highlight <args>

if g:vimrc#is_starting
  command -complete=filetype -nargs=*
      \ AutocmdFT Autocmd VimEnter * ++once Autocmd FileType <args>
  command -bar -complete=option -nargs=* SetG set <args>

  Autocmd VimEnter * ++once command! -complete=filetype -nargs=*
      \ AutocmdFT Autocmd FileType <args>
  Autocmd VimEnter * ++once command! -bar -complete=option -nargs=*
      \ SetG setglobal <args>
else
  command! -complete=filetype -nargs=* AutocmdFT Autocmd FileType <args>
  command! -bar -complete=option -nargs=* SetG setglobal <args>
endif

" syntax "{{{
AutocmdFT vim
    \ syntax keyword vimAutoCmd Autocmd skipwhite nextgroup=vimAutoEventList
AutocmdFT vim
    \ syntax keyword vimAutoCmd AutocmdFT nextgroup=vimAutoCmdSpace
AutocmdFT vim
    \ syntax keyword vimHighlight Highlight skipwhite nextgroup=vimHiBang,@vimHighlightCluster
AutocmdFT vim
    \ syntax keyword vimCommand contained SetG
AutocmdFT vim
    \ syntax region vimSet matchgroup=vimCommand start="\<\%(SetG\)\>" skip="\%(\\\\\)*\\.\n\@!" end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vim9Comment,vimSetString,vimSetMod
"}}}
"}}}

" シンボリックリンク先のファイルを開く "{{{
command! -bar OpenSymbolicTarget call OpenSymbolicTarget()
"}}}

" Terminal "{{{
if g:vimrc#is_nvim
  command! -bar Terminal execute 'belowright new term://' .. &shell
  command! -bar -nargs=? -addr=windows Resize execute 'resize <args> | set cmdheight=' .. &cmdheight

  cnoreabbrev <expr> terminal Cmdwhen(':', 'terminal', 'Terminal')
  cnoreabbrev <expr> resize Cmdwhen(':', 'resize', 'Resize')
endif
"}}}

if !exists(':DiffOrig') "{{{
  command -bar -nargs=0 DiffOrig
      \ vertical new | setlocal buftype=nofile |
      \ read ++edit # | 0d_ | diffthis | wincmd p | diffthis
endif "}}}
"}}}

" オプション "{{{
" options "{{{
set ambiwidth=single
SetG autoindent cindent copyindent smartindent
SetG expandtab shiftwidth=2 softtabstop=2 tabstop=4
set shiftround smarttab
SetG autoread
set backspace=indent,eol,start whichwrap+=h,l
set backup backupskip+=*~,*.o
let &backupdir = g:vimrc#dotvim .. '/.backup'
SetG breakindent breakindentopt=shift:2
set browsedir=buffer
SetG complete-=u | set completeopt=menuone,noselect,preview pumheight=8
set cmdheight=2
set confirm
SetG nocursorline
set diffopt+=context:2,vertical,indent-heuristic,algorithm:histogram
set display=lastline,uhex
set fillchars=fold:\ ,stl:\ ,stlnc:\ ,vert:\|
SetG nofixendofline
SetG foldenable foldlevel=1 foldmethod=syntax foldtext=Foldtext()
SetG formatoptions-=c formatoptions+=Bjmr
set guicursor=a:block-Cursor
set helpheight=10 helplang=ja
set hidden
set history=1000
set hlsearch ignorecase incsearch smartcase | nohlsearch
SetG iminsert=0 imsearch=-1
set laststatus=2
setglobal statusline =\ %2{Mode()}%{&paste?'\ \ \|\ p':''}
setglobal statusline+=\ \|\ %n
setglobal statusline+=\ \|\ %{pathshorten(fnamemodify(expand('%:p:h'),':~:s?[^/\\\\]\zs$?'..(g:vimrc#is_windows&&!&shellslash?'\\':'/')..'?'))}
setglobal statusline+=\ \|\ %{&filetype!=#'netrw'?empty(bufname())?gettext('[No\ Name]'):expand('%:t'):''}
setglobal statusline+=\ %R%M%{&modified\|\|&readonly?'\ ':''}
if has('patch-8.2.2854') || has('nvim-0.5.0')
  setglobal statusline+=%<%{%g:actual_curwin==#win_getid()?'%#StatusLineNC#':'%#Comment#'%}
else
  setglobal statusline+=%<%#StatusLineNC#
endif
if exists('+showcmdloc')
  setglobal statusline+=\ %S
endif
setglobal statusline+=%=%*
setglobal statusline+=\ %{(empty(&fileencoding)?&encoding:&fileencoding)..'/'..&fileformat}
setglobal statusline+=\ \|\ %{empty(&filetype)?&buftype==#'terminal'?'terminal':'?':&filetype}
setglobal statusline+=\ \|\ %4P
setglobal statusline+=\ \|%4l:%2c\ %#StatusLineNC#
"  N | 1 | ~/ | .vimrc +  <1b>          utf-8/unix | vim |  30% | 338:20
" set lazyredraw
SetG list | set listchars=tab:>\ ,nbsp:%
SetG matchpairs+=<:> | set showmatch
SetG modeline
set mouse=a
SetG nrformats+=alpha
SetG number relativenumber
let &packpath ..= ',' .. g:vimrc#dotvim .. '/pack'
set pastetoggle=<F2>
set scrolloff=2
set sessionoptions+=localoptions,resize,slash,unix sessionoptions-=blank
set shortmess+=cmrx shortmess-=t shortmess-=T
set showbreak==>
set showcmd
set showtabline=2
SetG signcolumn=auto
set splitbelow splitright
set nostartofline
set switchbuf=useopen,usetab
SetG synmaxcol=800
set timeout ttimeout timeoutlen=700 ttimeoutlen=50
set title
set undoreload=20000 | SetG undolevels=800
let &undodir = g:vimrc#dotvim .. '/.undo'
set updatecount=0 | SetG noswapfile
set updatetime=2000
set viewoptions+=localoptions,slash,unix
let &viewdir = g:vimrc#dotvim .. '/.view'
set viminfo-=<50 viminfo+=<100
set virtualedit+=block
set wildcharm=<Tab> wildignore+=*~,*.o wildignorecase wildmenu wildmode=longest:full
set winaltkeys=yes

if exists('+ballooneval')
  set ballooneval
endif
if exists('+balloonevalterm')
  set balloonevalterm
endif
if exists('+showcmdloc')
  set showcmdloc=statusline
endif
if exists('+smoothscroll')
  SetG smoothscroll
endif
if exists('+termguicolors') && !g:vimrc#is_windows
  set termguicolors
endif

if has('unnamedplus')
  set clipboard^=unnamedplus
else
  set clipboard^=unnamed
endif
if has('patch-8.2.0146') || has('nvim-0.5.0')
  SetG breakindentopt+=sbr
endif
if has('patch-8.2.4325') || has('nvim-0.8.0')
  set wildoptions=pum
endif
if has('patch-9.0.0656')
  SetG fillchars+=lastline:>
endif

if g:vimrc#is_nvim
  set clipboard=
elseif g:vimrc#is_wsl
  set clipboard=exclude:.*
else
  set clipboard=exclude:console\|linux
endif
if g:vimrc#is_unix
  set shell=bash
endif
if g:vimrc#is_nvim
  " 互換性がないので
  SetG noundofile
else
  SetG undofile
endif "}}}

" バックアップフォルダ等を作成 "{{{
for s:d in filter([
    \   &backup || &writebackup || &patchmode !=# '' ? 'backupdir' : '',
    \   &swapfile ? 'directory' : '', &undofile ? 'undodir' : '',
    \   &loadplugins ? 'packpath' : '', 'viewdir'
    \ ], { _, v -> !empty(v) })
  if s:d != '' && !s:mkdir(eval('&' .. s:d))
    execute 'set' s:d .. '&'
  endif
endfor
unlet s:d "}}}

" $VIMRUNTIME 以下の不要なプラグインを読み込まない "{{{
let g:loaded_2html_plugin = 1
let g:loaded_gzip = 1
let g:loaded_tar = 1
let g:loaded_tarPlugin = 1
let g:loaded_zip = 1
let g:loaded_zipPlugin = 1
let g:loaded_rrhelper = 1
let g:loaded_vimball = 1
let g:loaded_vimballPlugin = 1
let g:loaded_getscript = 1
let g:loaded_getscriptPlugin = 1
"}}}

" $VIMRUNTIME以下のプラグインの設定 "{{{
let g:netrw_clipboard = 0
let g:netrw_keepj = ''
let g:netrw_liststyle = 3
let g:netrw_sizestyle = 'H'
let g:netrw_use_errorwindow = 2
let g:netrw_winsize = -30
let g:netrw_wiw = 10
let g:vim_indent_cont = shiftwidth()*2
let g:vim_json_conceal = 0
"}}}
"}}}

" キーマップ "{{{
nnoremap <Leader> <Nop>

map <Nul> <C-Space>
map! <Nul> <C-Space>

" minttyだけ?
" map <C-j> <S-CR>
" map! <C-j> <S-CR>

nnoremap Y y$

noremap! jk <Esc>
snoremap jk <Esc>

" cnoremap <Esc><Esc> <C-c>

" fold "{{{
xnoremap za zo

" xnoremap <expr> zc 'zx' ..
"    \ index([
"    \   min([foldclosed('`<'), foldclosed('`>')]),
"    \   max([foldclosedend('`<'), foldclosedend('`>')])
"    \ ], line('.')) > 0 ? '<Esc>' : 'zo'
"}}}

" scroll "{{{
nnoremap zH zt
nnoremap zL zb

nnoremap <expr> <C-e>
    \ '<C-e>' .. (exists('+smoothscroll') && &smoothscroll ? 'g' : '') .. 'j'
nnoremap <expr> <C-y>
    \ '<C-y>' .. (exists('+smoothscroll') && &smoothscroll ? 'g' : '') .. 'k'
" noremap <C-u> <C-u>zz
" noremap <C-d> <C-d>zz
" noremap <C-f> <C-f>zz
" noremap <C-b> <C-b>zz
" noremap <ScrollWheelUp> 3<C-y>
" noremap <ScrollWheelDown> 3<C-e>
"}}}

" move / jump (current line) "{{{
noremap j gj
noremap k gk
noremap gj j
noremap gk k
sunmap j
sunmap k
sunmap gj
sunmap gk

noremap - ^
noremap ^ $
sunmap -
sunmap ^

" noremap! <C-p> <Up>
" noremap! <C-l> <Down>
" inoremap <C-k> <Left>
" cnoremap <C-k> <Space><BS><Left>
" inoremap <C-@> <Right>
" cnoremap <C-@> <Space><BS><Right>

" inoremap <C-y> <C-o>^
" cnoremap <C-y> <Home>
" noremap! <C-b> <End>
" cnoremap <C-e> <C-y>

cnoremap <C-a> <Home>

" cnoremap <A-b> <C-Right>
" cnoremap <A-f> <C-Left>
cnoremap <C-x> <C-Right>
cnoremap <C-z> <C-Left>
"}}}

" jump (other) "{{{
nnoremap go `^

nnoremap <expr> M winheight(winnr())/2 .. 'H'

nnoremap <Tab> <C-i>
nnoremap <S-Tab> <C-o>

nnoremap <expr> <C-w>w v:count > 0 ? '<C-w>w' : '<C-w>p'
nnoremap <C-w>p <C-w>P
nnoremap <C-w>j <C-w>w
nnoremap <C-w>k <C-w>W

nnoremap gm gf
nnoremap <silent> gf :<C-u>e <C-r>=empty(bufname()) ? '' : expand('%:h') .. '/'<CR><cfile><CR>
nnoremap <silent> <C-w>f :<C-u>split <C-r>=empty(bufname()) ? '' : expand('%:h') .. '/'<CR><cfile><CR>
nmap <silent> <C-w><C-f> <C-w>f
"}}}

" search "{{{
noremap n nzzzv
noremap N Nzzzv
sunmap n
sunmap N

nnoremap <silent> * :<C-u>let @/ = printf('\V%s', escape(expand('<cword>'), '\'))<Bar>set hlsearch<CR>wb
nnoremap <silent> g* :<C-u>let @/ = printf('\V\<lt>%s\>', escape(expand('<cword>'), '\'))<Bar>set hlsearch<CR>wb
"}}}

" カット時にブラックホールレジスタを使う "{{{
noremap c "_c
nnoremap C "_C
noremap D "_d
nnoremap DD "_dd
noremap x "_x
noremap X x
sunmap c
ounmap c
sunmap D
ounmap D
sunmap x
ounmap x
sunmap X
ounmap X
"}}}

" operator, textobj "{{{
xnoremap iq i'
onoremap iq i'
xnoremap iQ i"
onoremap iQ i"

onoremap . l

" マッチした文字列を選択
" TODO: マッチした文字列内か判定
" @/
onoremap / //e<CR>

" nnoremap gi '[v']
"}}}

" swap mapping "{{{
noremap m `
noremap ` m
sunmap m
sunmap `

nnoremap ~ g~
nnoremap g~ ~
"}}}

" disable mapping "{{{
" c. / cc に矯正
nnoremap s <Nop>
xnoremap s <Nop>
nnoremap S <Nop>
xnoremap S <Nop>

nnoremap # <Nop>
nnoremap g# <Nop>
"}}}

" command "{{{
nnoremap gs :<C-u>%s/
xnoremap gs :s/

cnoremap <C-n> <Down>
cnoremap <C-p> <Up>

nmap <Leader>w <C-w>
nnoremap <silent> <C-w>z :<C-u>pclose<Bar>cclose<Bar>lclose<CR>
nmap <silent> <C-w><C-z> <C-w>z

nnoremap <silent> <Leader>diff :<C-u>windo diff<C-r>=&diff?'off':'this'<CR><CR>

nnoremap <silent> <Leader>a :<C-u>Lexplore<CR>
nnoremap <silent> <Leader>A :<C-u>Lexplore %:h<CR>

" 誤爆防止
nnoremap Z <Nop>
nnoremap <silent> ZZ :<C-u>update<CR>
nnoremap <silent> ZQ
    \ :<C-u>call BDeleteSaveWindow(<C-r>=v:count > 0 ? v:count : bufnr()<CR>)<CR>

nnoremap <silent> <Leader><Tab> :<C-u>nohlsearch<CR>

nnoremap <silent> <Leader>tt :<C-u>tab split<CR>
nnoremap <expr><silent> <Leader>tc ':<C-u>' .. (v:count > 0 ? v:count : '') .. 'tabclose<CR>'
nnoremap <expr> gt <SID>delcount(v:count) ..
    \ ((tabpagenr() + max([v:count - 1, 0])) % tabpagenr('$') + 1) .. 'gt'

nnoremap <silent> <C-n> :<C-u><C-r>=v:count1<CR>bnext<CR>
nnoremap <silent> <C-p> :<C-u><C-r>=v:count1<CR>bprevious<CR>
nnoremap <silent> <Leader>bn :<C-u><C-r>=v:count1<CR>bnext<CR>
nnoremap <silent> <Leader>bN :<C-u><C-r>=v:count1<CR>bNext<CR>
nnoremap <silent> <Leader>bp :<C-u><C-r>=v:count1<CR>bprevious<CR>

nnoremap <silent> <Leader>cn :<C-u><C-r>=v:count1<CR>cnext<CR>
nnoremap <silent> <Leader>cN :<C-u><C-r>=v:count1<CR>cNext<CR>
nnoremap <silent> <Leader>cp :<C-u><C-r>=v:count1<CR>cprevious<CR>

nnoremap <silent> <Leader>ln :<C-u><C-r>=v:count1<CR>lnext<CR>
nnoremap <silent> <Leader>lN :<C-u><C-r>=v:count1<CR>lNext<CR>
nnoremap <silent> <Leader>lp :<C-u><C-r>=v:count1<CR>lprevious<CR>

nnoremap <silent> <Leader>h
    \ :<C-u>echo map(synstack(line('.'),col('.')),{_,v->synIDattr(v,'name')})<CR>

let g:foldmethods = ['indent', 'marker', 'syntax', 'expr']
call add(g:foldmethods, g:foldmethods[0])
nnoremap <silent> <Leader>sf
    \ :<C-u>setlocal foldmethod=<C-r>=g:foldmethods[index(g:foldmethods,&foldmethod)+1]<CR> foldmethod?<CR>zv
"}}}

" insert / delete / paste "{{{
inoremap <BS> <C-g>u<BS>
inoremap <CR> <C-]><C-g>u<CR>

cnoremap <C-g> <C-u>
inoremap <C-k> <C-o>"_d$

xnoremap p P
xnoremap P I<C-r>=getreg(v:register)<CR><Esc>

" undoしたときのカーソルの位置を行末にしたくないのでAではなくoから始める
" nmap o o<C-o>"_d0<BS><CR>

nnoremap <CR> o<Esc>
nnoremap <expr> <S-CR> 'O<Esc>j' .. v:count .. 'k'
inoremap <S-CR> <C-o>O
inoremap <C-CR> <C-o>o
nnoremap <C-Space> i<CR><Esc>
nnoremap <C-CR> i<CR><Esc>
"}}}

" completion "{{{
" inoremap <C-u> <C-p>
" cnoremap <C-u> <C-p>

inoremap <Plug>(vimrc_cr) <CR>
inoremap <Plug>(vimrc_tab) <Tab>
snoremap <Plug>(vimrc_tab) <Tab>
inoremap <expr> <Plug>(vimrc_complete-next) pumvisible() ? '<C-n>' : ''
inoremap <expr> <Plug>(vimrc_complete-prev) pumvisible() ? '<C-p>' : ''
inoremap <expr> <Plug>(vimrc_complete-manual_complete) pumvisible() ? '' : '<C-n>'
inoremap <expr> <Plug>(vimrc_complete-confirm) pumvisible() ? '<C-y>' : ''
inoremap <Plug>(vimrc_complete-file) <C-x><C-f>
inoremap <Plug>(vimrc_reindent) <C-f>
inoremap <expr> <Plug>(vimrc_cancel-complete) pumvisible() ? '<C-e>' : ''

inoremap <expr><silent> <CR> pumvisible() ? '<Plug>(vimrc_complete-confirm)' : '<Plug>(vimrc_cr)'
cnoremap <expr> <Tab> wildmenumode() ? '<C-n>' : '<Tab>'
inoremap <expr> <C-f> search('^\s*\%#', 'bcn', line('.')) > 0 ? '<Plug>(vimrc_reindent)' : '<Plug>(vimrc_complete-file)'
inoremap <expr> <C-e> pumvisible() ? '<Plug>(vimrc_cancel-complete)' : '<End>'
"}}}

" terminal "{{{
tnoremap <ScrollWheelUp> <C-\><C-n>
tnoremap <ScrollWheelDown> <C-\><C-n>

if g:vimrc#is_nvim
  tnoremap <C-w> <C-\><C-n><C-w>
  tnoremap <C-w>. <C-w>
  tnoremap <C-w>: <C-\><C-o>:
  tnoremap <expr> <C-w>" '<C-\><C-n>"' .. nr2char(getchar()) .. 'pa'
endif
"}}}
"}}}

" エンコード "{{{
set fileformats=unix,dos,mac
set fileencodings=utf-8

if g:vimrc#is_cygwin
  set fileencodings+=cp932,euc-jp
elseif g:vimrc#is_windows
  set fileencodings+=cp932
else
  set fileencodings+=euc-jp,sjis
endif

" http://www.kawaz.jp/pukiwiki/?vim (404)
" http://pcmania.jp/~moraz/howto/install.html#japanese (404)
" Kaoriya Vim 6 のvimrcから？ (http://elpeo.jp/diary/20031113p01.html)
" ファイルの漢字コード自動判別のために必要 (要iconv)
if has('iconv')
  set fileencodings-=euc-jp

  " iconvがeucJP-msに対応しているかをチェック
  if iconv('\x87\x64\x87\x6a', 'cp932', 'eucjp-ms') ==# '\xad\xc5\xad\xcb'
    let s:enc_euc = 'eucjp-ms'
    let s:enc_jis = 'iso-2022-jp-3'
    " iconvがJISX0213に対応しているかをチェック
  elseif iconv('\x87\x64\x87\x6a', 'cp932', 'euc-jisx0213') ==# '\xad\xc5\xad\xcb'
    let s:enc_euc = 'euc-jisx0213'
    let s:enc_jis = 'iso-2022-jp-3'
  else
    let s:enc_euc = 'euc-jp'
    let s:enc_jis = 'iso-2022-jp'
  endif

  " fileencodingsを構築
  if &encoding ==# 'utf-8'
    set fileencodings-=cp932 fileencodings-=sjis
    let &fileencodings = s:enc_jis .. ',' .. s:enc_euc ..
        \ (g:vimrc#is_windows ? ',cp932,' : ',sjis,') .. &fileencodings
  else
    set fileencodings-=utf-8 fileencodings-=ucs-2le fileencodings-=ucs-2
    let &fileencodings ..= ',' .. s:enc_jis .. ',utf-8,ucs-2le,ucs-2'

    if &encoding =~# '^\(euc-jp\|euc-jisx0213\|eucjp-ms\)$'
      set fileencodings-=euc-jp fileencodings-=euc-jisx0213 fileencodings-=eucjp-ms
      let &encoding = s:enc_euc
      let &g:fileencoding = s:enc_euc
    else
      let &fileencodings ..= ',' .. s:enc_euc
    endif
  endif

  unlet s:enc_euc
  unlet s:enc_jis
endif

" encodingをfileencodingsの最後に移動
execute 'set fileencodings-=' .. &encoding
execute 'set fileencodings+=' .. &encoding

" 日本語を含まない場合は fileencoding に encoding を使うようにする
Autocmd BufReadPost,FileReadPost,FilterReadPost *
    \ if &fileencoding =~# 'iso-2022-jp' && search("[^\x01-\x7e]", 'n', 0, 1000) == 0 |
    \   let &fileencoding = &encoding |
    \ endif "}}}

" terminal "{{{
" https://ttssh2.osdn.jp/manual/4/ja/usage/tips/vim.html
if !g:vimrc#is_gui && &term !~# 'cygwin\|win32\|linux' " &term =~# 'xterm' &&
  " set t_Co=256

  " for RLogin "{{{
  if &term ==# 'rlogin-color' && !g:vimrc#is_nvim
    if g:vimrc#is_starting
      " true color
      let &t_8f = "\e[38:2:%lu:%lu:%lum"
      let &t_8b = "\e[48:2:%lu:%lu:%lum"
      " let &t_8u = ""

      " 端末へ情報を要求
      let &t_RF = "\e]10;?\x07"
      let &t_RB = "\e]11;?\x07"
      let &t_RV = "\e[>c"

      " 下線
      " let &t_AU = ""
      " let &t_Ce = ""
      " let &t_Cs = ""

      " 打ち消し線
      let &t_Ts = "\e[9m"
      let &t_Te = "\e[29m"

      " カーソル
      let &t_RC = "\e[?12$p"
      let &t_VS = "\e[?12h"
      let &t_vs = "\e[?12l"
      " let &t_RS = ""
      " let &t_SC = "\e[<"
      " let &t_EC = "!q"
      let &t_SH = "\e[%p1%d q"

      " ウィンドウサイズ
      let &t_WS = "\e[8;%p1%d;%p2%dt"

      " ウィンドウタイトル
      let &t_ST = "\e[22;0t"
      let &t_RT = "\e[23;0t"

      " アイコンテキスト
      let &t_IS = "\e]1;"
      let &t_IE = "\x07"
      let &t_Si = "\e[22;0t"
      let &t_Ri = "\e[23;0t"

      " blacketed paste mode
      let &t_BE = "\e[?2004h"
      let &t_BD = "\e[?2004l"
      let &t_PS = "\e[200~"
      let &t_PE = "\e[201~"

      " フォーカスイベント
      let &t_fe = "\e[?1004h"
      let &t_fd = "\e[?1004l"
    endif

    execute "set <FocusGained>=\e[I"
    execute "set <FocusLost>=\e[O"

  " modifyOtherKeys "{{{
    " modifyCursorKeysとmodifyStringKeysも有効にする
    if g:vimrc#is_starting
      " 有効にすると一部のキー(DD, <C-r>")で問題があるのでmodifyOtherKeys以外を一旦無効化
      " let &t_TI = "\e[>1;2m\e[>4;2m\e[>5;2m"
      " let &t_TE = "\e[>1;m\e[>4;m\e[>5;m"
      let &t_TI = "\e[>4;2m"
      let &t_TE = "\e[>4;m"
    endif
  endif

  function! s:rlogin_modifyotherkeys()
    " Seen modifyOtherKeys: true にならないようにキーコードに対してマッピングする
    let modifers = [
        \   #{ name: 'S', code: 2 },
        \   #{ name: 'A', code: 3 },
        \   #{ name: 'A-S', code: 4 },
        \   #{ name: 'C', code: 5 },
        \   #{ name: 'C-S', code: 6 },
        \   #{ name: 'A-C', code: 7 },
        \   #{ name: 'A-C-S', code: 8 }
        \ ]
    let keys = [
        \   #{ name: 'BS', code: 8 },
        \   #{ name: 'Tab', code: 9 },
        \   #{ name: 'CR', code: 13 }
        \ ]

    for modifer in modifers
      for key in keys
        execute 'map <special>'
            \ printf('<Esc>[27;%d;%d~', modifer['code'], key['code'])
            \ printf('<%s-%s>', modifer['name'], key['name'])
        execute 'map! <special>'
            \ printf('<Esc>[27;%d;%d~', modifer['code'], key['code'])
            \ printf('<%s-%s>', modifer['name'], key['name'])
      endfor
    endfor

    cnoremap <special><expr> <S-Tab> wildmenumode() ? '<C-p>' : '<Tab>'
  endfunction

  Autocmd VimEnter * ++once
      \ if !g:vimrc#is_nvim && GetXTVersion() =~# '^RLogin' |
      \   call s:rlogin_modifyotherkeys() |
      \ endif
  "}}}
  "}}}

  " OSC52でのコピー "{{{
  if g:vimrc#is_nvim
    " heredocだと構文表示がダメになるので
    lua
        \ function write_stdout(data)
        \   local uv = vim.uv or vim.loop
        \   local stdout = uv.new_tty(1, false)
        \
        \   stdout:write(data)
        \   stdout:close()
        \ end
  endif

  function! s:paste64(text) abort
    let str = join(systemlist('base64 --wrap=0', a:text), '')
    let seq = printf("\e]52;;%s\e\\", str)

    if g:vimrc#is_nvim
      call v:lua.write_stdout(seq)
    else
      let blob = list2blob(str2list(seq))
      call writefile(blob, '/dev/tty', 'ab')
    endif
  endfunction

  nnoremap <silent> <Leader>y :<C-u>call <SID>paste64(@")<CR>

  if g:vimrc#is_nvim
    let g:clipboard = #{
        \   name: 'myClipboard',
        \   copy: {
        \     '+': { lines, _ -> s:paste64(lines) },
        \     '*': { lines, _ -> s:paste64(lines) }
        \   },
        \   paste: {
        \     '+': { -> [] },
        \     '*': { -> [] }
        \   },
        \   cache_enabled: 1
        \ }
  endif
  "}}}

  " 挿入モードを出るときにIMEを自動で切る "{{{
  " https://qiita.com/U25CE/items/0b40662a22162907efae#%E7%AB%AF%E6%9C%AB%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3
  if g:vimrc#is_starting && !g:vimrc#is_nvim
    let &t_SI ..= "\e[<r"
    let &t_EI ..= "\e[<s\e[<0t"
    let &t_te ..= "\e[<0\e[<s"
  endif "}}}

  " ESCキーの待ちをなくす "{{{
  if g:vimrc#is_starting && !g:vimrc#is_nvim
    let &t_ti ..= "\e[?7727h"
    let &t_te ..= "\e[?7727l"
  endif

  function! s:fast_esc_map()
    noremap <special> <Esc>O[ <Esc>
    snoremap <special> <Esc>O[ <Esc>
    inoremap <special> <Esc>O[ <Esc>
    cnoremap <special> <Esc>O[ <C-c>

    " <C-r><Esc>などで'O['が残るときの対処
    noremap <special><expr> O getchar(0) ==# char2nr('[') ? '' : 'O'
    noremap! <special><expr> O getchar(0) ==# char2nr('[') ? '' : 'O'
  endfunction

  Autocmd VimEnter * ++once
      \ if !g:vimrc#is_nvim && !empty(GetXTVersion()) && GetXTVersion() !~# '^WezTerm' |
      \   call s:fast_esc_map() |
      \ endif
  "}}}

  " 縦分割時のスクロールの高速化 "{{{
  " https://qiita.com/kefir_/items/c725731d33de4d8fb096
  if 0 && !g:vimrc#is_nvim
    " set nottyfast
    function! s:enable_vsplit_mode() abort "{{{
      " enable origin mode and left/right margins
      let &t_CS = 'y'
      let &t_CV = "\e[%i%p1%d;%p2%ds"
      " let &t_te = "\e[?6;69l" .. &t_te
      let &t_te = "\e[?6;69l\e[999H" .. &t_te
      " let &t_te = "\e7\e[?6;69l\e8" .. &t_te
      let &t_ti ..= "\e[?6;69h"
      call writefile(["\e[?6;69h"], '/dev/tty', 'ab')
    endfunction "}}}

    " old vim does not ignore CPR
    " map <special> <Esc>[3;3R <Nop>

    " new vim can't handle CPR with direct mapping
    " map <special><expr> <Esc>[3;3R <SID>enableVsplitMode()
    map <special><expr> <t_F9> <SID>enableVsplitMode()

    if g:vimrc#is_starting
      let &t_F9 = "\e[3;3R"
      let &t_RV ..= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
    endif
  endif "}}}

  " 端末のバージョン情報を取得 "{{{
  " 応答が DCS (ESC P) > | VERSION ST (ESC \)で返ってくるのでどうにかして取得
  function! GetXTVersion() abort
    " unmap <Esc>P><Bar>
    " let &t_ti = substitute(&t_ti, "\e[>0q", '', '')

    if exists('g:xtversion')
      return g:xtversion
    elseif exists('$TERM_PROGRAM')
      let g:xtversion = $TERM_PROGRAM .. ' ' .. $TERM_PROGRAM_VERSION
      return g:xtversion
    elseif g:vimrc#is_nvim
      " TODO
      let g:xtversion = ''
      return g:xtversion
    endif

    call writefile(list2blob(str2list("\e[>0q")), '/dev/tty', 'ab')
    sleep 80m
    call s:parse_response()

    return g:xtversion
  endfunction

  function! s:parse_response() abort
    let res = []
    let i = 1
    while 1
      let c = getchar(0)
      " echomsg printf("%d, %s", i, string(c))
      if !c
        break
      elseif i ==# 1 && c ==# char2nr("\e")
        let i += 1
      elseif i ==# 2 && c ==# char2nr('P')
        let i += 1
      elseif i ==# 3 && c ==# char2nr('>')
        let i += 1
      elseif i ==# 4 && c ==# char2nr('|')
        let i += 1
      elseif i ==# 5
        if c ==# char2nr("\e")
          let i += 1
        else
          let res += [c]
        endif
      elseif i ==# 6 && c ==# char2nr('\')
        break
      else
        echomsg 'wrong response'
        while getchar(0) | endwhile
        break
      endif
    endwhile

    let g:xtversion = list2str(res)
  endfunction

  " if g:vimrc#is_starting && !g:vimrc#is_nvim
    " nnoremap <special><expr> <Esc>P><Bar> GetXTVersion()
    " let &t_ti ..= "\e[>0q"
  " endif "}}}
endif "}}}

" ColorScheme "{{{
set background=dark
Highlight ColorColumn ctermbg=233 guibg=#181818
" Highlight Folded ctermfg=247 ctermbg=234 guibg=#303030
Highlight NonText ctermfg=blue guifg=blue

Highlight CursorLineNr ctermbg=NONE guibg=NONE
" Highlight LineNr ctermfg=darkgreen guifg=#00c000
Highlight SignColumn ctermbg=NONE guibg=NONE
" Highlight StatusLineNC ctermfg=235

" Highlight TabLineFill ctermfg=236

" Highlight Pmenu ctermfg=black ctermbg=lightgray guifg=black guibg=lightgray
" Highlight PmenuSbar ctermfg=black guifg=black
" Highlight PmenuSel ctermfg=yellow ctermbg=darkblue guifg=yellow guibg=blue
" Highlight PmenuThumb ctermfg=darkblue guifg=blue

" Highlight DiffChange ctermbg=25 guibg=#004060
" Highlight DiffText ctermbg=18 guibg=#000080
Highlight DiffAdd ctermfg=NONE guifg=NONE
Highlight DiffChange ctermfg=NONE guifg=NONE
Highlight DiffDelete ctermfg=NONE guifg=NONE
Highlight DiffText ctermfg=NONE guifg=NONE

" コメントのハイライトがおかしいので以前のシンタックスを適用
" https://github.com/vim/vim/issues/11307
if has('patch-9.0.652') && !has('patch-9.0.1025')
  AutocmdFT vim syntax match vimLineComment +^[ \t:]*".*$+ contains=@vimCommentGroup,vimCommentString,vimCommentTitle
endif
"}}}

" autocmd "{{{
" カレントウィンドウのみカーソル行を強調 "{{{
Autocmd WinLeave * setlocal nocursorline
Autocmd WinEnter,BufWinEnter *
    \ if !&previewwindow | setlocal cursorline | endif
"}}}

" 保存したときのカーソル位置へ移動 "{{{
Autocmd BufReadPost ?*
    \ if line("'\"") > 0 && line ("'\"") <= line('$') |
    \   execute "normal! g'\"zv" |
    \ endif
"}}}

" その他 "{{{
" Autocmd QuickfixCmdPost make call QfMakeConv(&fileencoding, &encoding)
" if g:vimrc#is_windows
"   Autocmd QuickfixCmdPost make call QfMakeConv('utf-8', 'cp932')
" else
"   Autocmd QuickfixCmdPost make call QfMakeConv('cp932', 'utf-8')
" endif

AutocmdFT * setlocal formatoptions-=o
" AutocmdFT * if &commentstring !~# '^ ' |
"    \ let &commentstring = ' ' . &commentstring | endif
AutocmdFT c setlocal omnifunc=ccomplete#Complete
AutocmdFT * if &omnifunc ==# '' |
    \ setlocal omnifunc=syntaxcomplete#Complete | endif
AutocmdFT diff,git,help,netrw,qf
    \ noremap <buffer><silent> q :<C-u>bwipeout<CR>
AutocmdFT qf nnoremap <buffer> <CR> <CR>zv
AutocmdFT qf nnoremap <buffer> j j
AutocmdFT qf nnoremap <buffer> k k
AutocmdFT qf nnoremap <buffer> gj gj
AutocmdFT qf nnoremap <buffer> gk gk
Autocmd CmdwinEnter * nnoremap <buffer><silent> q :<C-u>q<CR>
Autocmd CmdwinEnter * nnoremap <buffer><silent> <CR> <CR>
AutocmdFT vim,help setlocal keywordprg=:help
Autocmd BufNewFile *.bat setlocal fileencoding=cp932 fileformat=dos
execute 'Autocmd BufReadPre' &backupskip 'setlocal noundofile'
" Autocmd CmdlineChanged : if !wildmenumode() && len(getcompletion(getcmdline(), 'cmdline')) > 1 | call feedkeys("\<Tab>") | endif
if g:vimrc#is_nvim
  Autocmd TermOpen * setlocal nobuflisted nonumber norelativenumber winfixheight
  Autocmd TermOpen * startinsert
  Autocmd TermClose * if !v:event.status | execute 'bdelete! ' .. expand('<abuf>') | endif
  Autocmd TermOpen * resize 15
elseif has('terminal')
  Autocmd TerminalWinOpen * setlocal nobuflisted nonumber norelativenumber winfixheight
  Autocmd TerminalWinOpen * nnoremap <buffer><silent><expr> q
      \ term_getstatus(bufnr()) =~# 'finished' ? ':<C-u>q<CR>' : ''
  Autocmd TerminalWinOpen * if empty(&termwinsize) | resize 15 | endif
endif
Autocmd BufWinEnter,ColorScheme,FileType * call Highlights()
if g:vimrc#is_nvim
  Autocmd TermOpen * call Highlights()
elseif has('terminal')
  Autocmd TerminalWinOpen * call Highlights()
endif
Autocmd OptionSet foldcolumn,number,numberwidth,relativenumber,signcolumn
    \ call s:set_colorcolumn()
Autocmd ColorScheme * unlet! g:terminal_ansi_colors
AutocmdFT qf setlocal nobuflisted
AutocmdFT vim setlocal foldlevel=0 foldmethod=marker | normal! zv
AutocmdFT toml setlocal foldlevel=0 foldmethod=indent | normal! zv

if vimrc#is_nvim
  Autocmd UIEnter * doautocmd ColorScheme
endif

if exists('+vartabstop')
  AutocmdFT diff setlocal vartabstop=9,8
  AutocmdFT diff let &l:varsofttabstop =
      \ printf('%d,%d', &l:softtabstop + 1, &l:softtabstop)
endif

Autocmd BufWinLeave * ++nested if &diff | diffoff | endif
Autocmd OptionSet diff
    \ if v:option_new |
    \   execute 'nnoremap <buffer> dp dp]c' |
    \   execute 'nnoremap <buffer> do do]c' |
    \   setlocal cursorlineopt=number norelativenumber |
    \ else |
    \   silent! execute 'unmap <buffer> dp' |
    \   silent! execute 'unmap <buffer> do' |
    \   setlocal cursorlineopt< relativenumber |
    \ endif

" netrwのバッファに飛ぶのでそのときに削除する
Autocmd BufEnter * if isdirectory(expand('<afile>')) | setlocal bufhidden=wipe | endif

if g:vimrc#is_nvim
  Autocmd TermOpen * Autocmd WinLeave <buffer>
      \ if !pumvisible() | stopinsert | endif
elseif has('terminal')
  " Autocmd TerminalWinOpen * Autocmd WinLeave <buffer>
  "    \ if !pumvisible() | stopinsert | endif
endif

augroup Vimrc_bin
  autocmd!
  autocmd BufReadPre *.bin,*.exe,*.dll setlocal binary
  autocmd BufReadPost *
      \ if &binary |
      \   execute 'silent %!xxd -g 1' |
      \   setlocal filetype=xxd noendofline |
      \   execute 'Autocmd BufWritePre <buffer=abuf> %!xxd -r' |
      \   execute 'Autocmd BufWritePost <buffer=abuf> silent %!xxd -g 1' |
      \   execute 'Autocmd BufWritePost <buffer=abuf> setlocal nomodified' |
      \ endif
augroup END
"}}}
"}}}

" plugin "{{{
packadd! matchit

if g:vimrc#is_starting
  " 画面切り替え前のメッセージを遅延させる
  let s:msg = execute([
      \   'source ' .. g:vimrc#dotvim .. '/dein.vim'
      \ ], 'silent')
  Autocmd VimEnter * ++once
      \ for s:line in split(s:msg, "\n") |
      \   echomsg s:line |
      \ endfor
else
  execute 'source ' .. g:vimrc#dotvim .. '/dein.vim'
endif
"}}}

Autocmd VimEnter * ++once doautoall Vimrc ColorScheme,FileType

if get(g:, 'colors_name', '') ==# ''
  colorscheme desert
endif

filetype plugin indent on
syntax on

if !g:vimrc#is_starting
  doautoall Vimrc VimEnter
endif
