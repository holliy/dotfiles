[[plugins]]
repo = 'bkad/CamelCaseMotion'
hook_source = '''
  noremap gw <Plug>CamelCaseMotion_w
  noremap gb <Plug>CamelCaseMotion_b
  noremap ge <Plug>CamelCaseMotion_e
  sunmap gw
  sunmap gb
  sunmap ge

  onoremap icw <Plug>CamelCaseMotion_iw
  xnoremap icw <Plug>CamelCaseMotion_iw
  onoremap icb <Plug>CamelCaseMotion_ib
  xnoremap icb <Plug>CamelCaseMotion_ib
  onoremap ice <Plug>CamelCaseMotion_ie
  xnoremap ice <Plug>CamelCaseMotion_ie
'''

[[plugins]]
repo = 'cohama/lexima.vim'
hook_source = '''
  let g:lexima_map_escape = 'jk'
  " let g:lexima_accept_pum_with_enter = 1

  inoremap <expr><silent> <Plug>(vimrc_cr) lexima#expand('<lt>CR>', 'i')
  inoremap <expr><silent> <Plug>(vimrc_tab) lexima#expand('<lt>TAB>', 'i')

  if g:vimrc#is_nvim
    Autocmd TermOpen * let b:lexima_disabled = 1
  elseif has('terminal')
    Autocmd TerminalWinOpen * let b:lexima_disabled = 1
  endif
'''
hook_post_source = '''
  let save_cr_mapping = maparg('<CR>', 'i', 0, 1)
  let save_tab_mapping = maparg('<Tab>', 'i', 0, 1)

  let quotes = [
      \   #{ start: "'", end: "'" }, #{ start: '"', end: '"' },
      \ ]
  let brackets = [
      \   #{ start: '(', end: ')' }, #{ start: '{', end: '}' },
      \   #{ start: '[', end: ']' },
      \ ]
  let comments = [
      \   #{
      \     start: '/*', end: '*/', head: '*',
      \     filetype: ['c', 'cpp', 'cs', 'java', 'rust', 'scala'],
      \   },
      \   #{ start: '{-', end: '-}', with_bracket: 1, filetype: ['haskell'] },
      \   #{ start: '{-#', end: '#-}', filetype: ['haskell'] },
      \ ]

  " call filter(g:lexima#default_rules,
  "    \ { _, v -> !has_key(v, 'at') || v.at !=# '\\\%#' })
  call lexima#set_default_rules()

  " quote in lisp "{{{
  call lexima#add_rule(#{
      \   char: "'",
      \   filetype: ['lisp', 'scheme'],
      \ })
  call lexima#add_rule(#{
      \   char: "'",
      \   input_after: "'",
      \   filetype: ['lisp', 'scheme'],
      \   syntax: ['Comment', 'Constant', 'String'],
      \ })
  call lexima#add_rule(#{
      \   at: "\\%#'",
      \   char: "'",
      \   leave: 1,
      \   filetype: ['lisp', 'scheme'],
      \   syntax: ['Comment', 'Constant', 'String'],
      \ })
  "}}}

  " comment "{{{
  for c in comments
    call lexima#add_rule(#{
        \   at: '\V' .. c.start[:-2] .. '\%#\$',
        \   char: c.start[-1:],
        \   input_after: c.end,
        \   filetype: c.filetype,
        \ })
    call lexima#add_rule(#{
        \   at: '\V' .. c.start .. '\%#' .. c.end,
        \   char: '<Space>',
        \   input_after: '<Space>',
        \   filetype: c.filetype,
        \ })
    call lexima#add_rule(#{
        \   at: '\V' .. c.start .. '\%#' .. c.end,
        \   char: '<BS>',
        \   input: repeat('<BS>', len(c.start)),
        \   delete: len(c.end),
        \   filetype: c.filetype,
        \ })
    call lexima#add_rule(#{
        \   at: '\V' .. c.start .. ' \%# ' .. c.end,
        \   char: '<BS>',
        \   delete: 1,
        \   filetype: c.filetype,
        \ })

    if has_key(c, 'head')
      call lexima#add_rule(#{
          \   at: '\V\^ ' .. c.head .. ' \%# \?' .. c.end,
          \   char: '<BS>',
          \   input: '<BS><BS>',
          \   filetype: c.filetype,
          \ })
      call lexima#add_rule(#{
          \   at: '^ \%#',
          \   char: '<Space>',
          \   input: c.head .. '<Space>',
          \   filetype: c.filetype,
          \   syntax: ['Comment'],
          \ })
    endif

    if get(c, 'with_bracket', 0)
      call lexima#add_rule(#{
          \   at: '\V' .. c.start[:-2] .. '\%#' .. c.end[1:] .. '\$',
          \   char: c.start[-1:],
          \   input_after: c.end[:0],
          \   filetype: c.filetype,
          \ })
    endif
  endfor "}}}

  " bracket "{{{
  for pair in brackets
    call lexima#add_rule(#{
        \   at: '\V' .. pair.start .. '\%#' .. pair.end,
        \   char: '<CR>',
        \   input: '<CR>\ ',
        \   input_after: '<CR>\ ',
        \   filetype: ['vim'],
        \ })
    " カッコの間に改行を入力時、継続行にして3行に展開
    call lexima#add_rule(#{
        \   at: pair.start .. '\%#$',
        \   except: '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s*\\.*)\n)*\1\s*\\\s*\' .. pair.end,
        \   char: '<CR>',
        \   input: '<CR>\ ',
        \   input_after: '<CR>\ ' .. pair.end,
        \   filetype: ['vim'],
        \ })
    " ↑の展開後の途中の改行でも行継続
    call lexima#add_rule(#{
        \   at: '\C\v^(\s*)\S.*\' .. pair.start .. '%#\n%(%(\s*|\1\s*\\.*)\n)*\1\s*\\\s*\' .. pair.end,
        \   char: '<CR>',
        \   input: '<CR>\ ',
        \   filetype: ['vim'],
        \ })
    call lexima#add_rule(#{
        \   at: '\%#\w',
        \   char: pair.start,
        \ })
  endfor

  call lexima#add_rule(#{
      \   at: '\\%\?\%#',
      \   char: '(',
      \   input_after: '\)',
      \   filetype: ['vim'],
      \ })
  "}}}

  " 継続行
  call lexima#add_rule(#{
      \   at: '^\s*\\\(\s*\).\{-}\%#',
      \   char: '<CR>',
      \   input: '<CR>\\\1',
      \   with_submatch: 1,
      \   filetype: ['vim'],
      \ })

  " 補完した文字の後ろに<Tab>で移動 "{{{
  for pair in brackets + quotes
    call lexima#add_rule(#{
        \   at: '\V\%#\( \?\|\n\s\*\)' .. pair.end,
        \   char: '<Tab>',
        \   leave: pair.end,
        \ })
  endfor

  for c in comments
    call lexima#add_rule(#{
        \   at: '\V\S\%# \?' .. c.end,
        \   char: '<Tab>',
        \   leave: c.end,
        \   filetype: c.filetype,
        \   syntax: ['Comment'],
        \ })
  endfor

  call lexima#add_rule(#{
      \   at: '\%#\\)',
      \   char: '<Tab>',
      \   leave: '\\)',
      \   filetype: ['vim'],
      \ })
  "}}}

  " prehook for neosnippet "{{{
  " 補完メニューを開いている間に入力したときにleximaのマッピングの途中でCompleteDoneが発火してそう
  " 先にCompleteDoneを処理させると選択モードになる場合があって<C-]>が誤爆するので適当に入力して選択モードを抜ける
  for char in keys(lexima#insmode#get_rules())
    execute printf(
        \   "inoremap <expr><silent> %s (pumvisible() ? '<C-y>a<BS>' : '') .. lexima#expand(%s, 'i')",
        \   char,
        \   string(lexima#string#to_mappable(char)),
        \ )
  endfor "}}}

  " inoremap <expr><silent> <CR> pumvisible() ? '<Plug>(vimrc_complete-confirm)' : '<Plug>(vimrc_cr)'
  if !empty(save_cr_mapping)
    call mapset('i', 0, save_cr_mapping)
  endif
  if !empty(save_tab_mapping)
    call mapset('i', 0, save_tab_mapping)
  endif
'''

[[plugins]]
repo = 'editorconfig/editorconfig-vim'
hook_source = '''
  " バッファ作成時にmodifiedになるので一旦無効化
  " let g:EditorConfig_enable_for_new_buf = 1
'''
hook_post_source = '''
  function! s:editorconfig_enabled(config) abort
    if has_key(a:config, 'charset')
      let value = a:config.charset

      execute 'set fileencodings-=' .. value
      execute 'set fileencodings^=' .. value

      let &g:fileencoding = value
    endif

    if has_key(a:config, 'end_of_line')
      let mapping = #{ lf: 'unix', cr: 'mac', crlf: 'dos' }
      let value = mapping[a:config.end_of_line]

      execute 'set fileformats-=' .. value
      execute 'set fileformats^=' .. value

      let &g:fileformat = value
    endif

    return 0
  endfunction

  call editorconfig#AddNewHook(function('s:editorconfig_enabled'))
'''

[[plugins]]
repo = 'gamoutatsumi/ddc-sorter_ascii'
depends = ['ddc']

[[plugins]]
repo = 'itchyny/landscape.vim'
hook_post_source = '''
  colorscheme landscape
  doautocmd ColorScheme
  Highlight ModeMsg NONE
  Highlight WarningMsg ctermbg=NONE guibg=NONE
'''

[[plugins]]
repo = 'itchyny/lightline.vim'
hook_source = '''
  " g:lightline "{{{
  let g:lightline = #{
      \   enable: #{
      \     statusline: 1,
      \     tabline: 1,
      \   },
      \   colorscheme: 'landscape',
      \   active: #{
      \     left: [['mode', 'skk', 'paste'], ['bufnum', 'git', 'directory', 'filename', 'readonly', 'modified'], ['showcmd']],
      \     right: [['trailing', 'lineinfo'], ['percent'], ['truncate', 'fileinfo', 'filetype']],
      \   },
      \   inactive: #{
      \     left: [['bufnum', 'git', 'directory', 'filename', 'readonly', 'modified']],
      \     right: [['lineinfo'], ['percent']],
      \   },
      \   tabline: #{
      \     left: [['buffers']],
      \     right: [['close']],
      \   },
      \   tab: #{
      \     active: ['tabnum', 'filename', 'modified'],
      \     inactive: ['bufnum', 'filename', 'modified'],
      \   },
      \   component: #{
      \     close: '%999X x ',
      \     lineinfo: "L %3l:%-2v",
      \     paste: '%{&paste?"P":""}',
      \     percent: '%4P',
      \     showcmd: exists('+showcmdloc') ? '%S' : '',
      \     truncate: '%<',
      \   },
      \   component_visible_condition: #{
      \     truncate: '0',
      \   },
      \   component_function: #{
      \     directory: 'LightlineDirectory',
      \     filename: 'LightlineFilename',
      \     fileinfo: 'LightlineFileinfo',
      \     filetype: 'LightlineFiletype',
      \     mode: 'LightlineMode',
      \     modified: 'LightlineModified',
      \     readonly: 'LightlineReadonly',
      \   },
      \   component_expand: #{
      \     buffers: 'LightlineBuffers',
      \     trailing: 'LightlineTrailingSpaceWarning',
      \   },
      \   component_function_visible_condition: #{
      \     directory: '&filetype!=#"netrw"',
      \   },
      \   component_type: #{
      \     buffers: 'tabsel',
      \     trailing: 'error',
      \   },
      \   tab_component_function: #{
      \     bufnum: 'lightline#tab#tabnum',
      \     filename: 'LightlineFilenameB',
      \     modified: 'LightlineModified',
      \     tabnum: 'LightlineTabnum',
      \   },
      \   separator: #{ left: "", right: "" },
      \ }

  if g:vimrc#is_windows && g:vimrc#is_gui
    let g:lightline.subseparator = #{ left: "|", right: "|" }
  else
    let g:lightline.subseparator = #{ left: "│", right: "│" }
  endif

  if !empty(dpp#get('statusline_skk'))
    let g:lightline.component_function['skk'] = 'statusline_skk#mode'
  endif
  if !empty(dpp#get('gitbranch'))
    let g:lightline.component_function['git'] = 'gitbranch#name'
  endif
  "}}}

  " タブラインにバッファ一覧を表示 "{{{
  function! LightlineBuffers() abort "{{{
    " return:タブが5個以上の時ウィンドウの幅によって5個から17個表示する
    let [active_bn, alt_bn, last_bn, tn] = [bufnr(), winbufnr(winnr('#')), bufnr('$'), tabpagenr()]
    let [left, mid, right] = [[], [], []]
    let fold = '...'
    let max_side_tabs = min([max([&columns/20/2, 2]), 12]) " left, rightそれぞれから表示する数

    if getbufvar(active_bn, '&buftype') ==# 'popup'
      let active_bn = winbufnr(t:winid)
    elseif IgnoreBuffer(active_bn)
      if !IgnoreBuffer(alt_bn)
        let active_bn = alt_bn
      else
        " タブページ内のウィンドウから探す
        for bn in tabpagebuflist()
          if !IgnoreBuffer(bn)
            let active_bn = bn
            break
          endif
        endfor
      endif
    endif

    for binfo in getbufinfo()
      let bn = binfo.bufnr
      if bn ==# active_bn
        call add(mid, printf('%%%dT%%{lightline#onetab(%d, 1)}', tn, bn))
        continue
      endif

      if IgnoreBuffer(bn)
        continue
      endif

      call add(bn < active_bn ? left : right, printf('%%%dT%%{lightline#onetab(%d, 0)}', tn, bn) .. (bn ==# last_bn ? '%T' : ''))
    endfor

    let left_len = len(left)
    let right_len = len(right)
    if left_len + right_len > max_side_tabs*2
      " let max_left_tabs = max([left_len])
      if left_len > max_side_tabs
        let left = [fold] + left[-max_side_tabs:]
      endif

      if right_len > max_side_tabs
        let right = right[:max_side_tabs - 1] + [fold]
      endif
    endif
    return [left, mid, right]
  endfunction "}}}

  " 更新されないので再描画
  Autocmd BufAdd,BufDelete * redrawtabline
  "}}}

  function! LightlineModified(bn = 0) abort "{{{
    let bn = a:bn
    if bn ==# 0
      let bn = bufnr()
    endif

    return IgnoreBuffer(bn) ? '' :
        \ getbufvar(bn, '&filetype') =~# 'netrw' ? '' :
        \ getbufvar(bn, '&buftype') ==# 'terminal' ? '' :
        \ getbufvar(bn, '&modified') ? '+' :
        \ getbufvar(bn, '&modifiable') ? '' : '-'
  endfunction "}}}

  function! LightlineFilenameB(bufnr) abort "{{{
    let l:fname = fnamemodify(bufname(a:bufnr), ':t')
    let l:alt_fname = fnamemodify(bufname(0), ':t')
    return IsCommandLineWindow(a:bufnr) ? l:alt_fname :
        \ empty(l:fname) ? gettext('[No Name]') : l:fname
  endfunction "}}}

  function! LightlineTabnum(_ = v:none) abort "{{{
    return tabpagenr()
  endfunction "}}}

  let s:readonlychar = 'x'
  function! LightlineReadonly() abort "{{{
    return IgnoreBuffer() ? '' :
        \ &filetype =~# 'netrw' ? '' :
        \ &readonly ? s:readonlychar : ''
  endfunction "}}}

  function! LightlineFilename() abort "{{{
    if &filetype ==# 'netrw'
      let save_shellslash = &shellslash
      set shellslash

      let curdir = fnamemodify(b:netrw_curdir, ':~:.:s?[^/]\zs$?/?')

      let &shellslash = save_shellslash
      return curdir
    else
      let l:fname = expand('%:t')
      return IsCommandLineWindow() ? '' :
          \ &filetype ==# 'qf' ?
          \   win_gettype() ==# 'loclist' ? '[Location List]' : '[Quickfix List]' :
          \ &filetype =~# '\<lsp-hover\>' ? '[LSP Hover Information]' :
          \ empty(l:fname) ? gettext('[No Name]') : l:fname
    endif
  endfunction "}}}

  function! LightlineFiletype() abort "{{{
    return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : '?') : ''
  endfunction "}}}

  function! LightlineFileinfo() abort "{{{
    return IgnoreBuffer() || winwidth(0) <= 75 ? '' :
        \ (strlen(&fileencoding) ? &fileencoding : &encoding) ..
        \ '/' .. &fileformat
  endfunction "}}}

  function! LightlineMode() abort "{{{
    return IsCommandLineWindow() ? 'Cmd' :
        \ &filetype ==# 'help' && !&modifiable ? 'Help' :
        \ &filetype ==# 'qf' ? 'QuickFix' :
        \ (winwidth(0) > 60 ? lightline#mode() : '')
  endfunction "}}}

  function! LightlineTrailingSpaceWarning() abort "{{{
    if IgnoreBuffer()
      return ''
    endif

    let l:space_line = search('\S\zs\s\+$', 'nw')
    return l:space_line != 0 ? 'Space: L' .. l:space_line : ''
  endfunction

  Autocmd BufWritePost * call LightlineTrailingSpaceWarning() | call lightline#update()
  "}}}

  function! LightlineDirectory() abort "{{{
    if &filetype ==# 'netrw'
      return ''
    endif

    let save_shellslash = &shellslash
    set shellslash

    let fname = expand('%:p:h')

    if !empty(dpp#get('gin'))
      let scheme = matchstr(fname, '^\w\+://')[:-4]
      if !empty(scheme) && scheme =~# '^gin.*'
        let fname = gin#util#worktree() .. '/' .. gin#util#expand('%:p:h')
      endif
    endif

    let dir = fnamemodify(fname, ':~:.')
    let dir = substitute(dir, '[^/]\zs$', '/', '')

    let &shellslash = save_shellslash
    return pathshorten(dir)
  endfunction "}}}
  "}}}
'''
hook_post_source = '''
  call lightline#init()
  call lightline#colorscheme()
  call lightline#update()

  " ポップアップ表示中にwin_getidの対象がポップアップウィンドウになることがあるのでwinidを退避
  let t:winid = win_getid()
  Autocmd WinEnter * let t:winid = win_getid()
'''

[[plugins]]
repo = 'itchyny/vim-gitbranch'

[[plugins]]
repo = 'itchyny/vim-qfedit'

[[plugins]]
repo = 'itchyny/vim-haskell-indent'
on_ft = 'haskell'
hook_source = '''
  let g:haskell_indent_disable_case = 1
'''

[[plugins]]
repo = 'junegunn/fzf'
merged = 0
hook_post_update = 'call fzf#install() | unlet g:loaded_fzf | runtime! plugin/fzf.vim'
hook_source = '''
  let g:fzf_colors = #{
      \   border: ['fg', 'Folded'],
      \ }
'''

[[plugins]]
repo = 'junegunn/fzf.vim'
name = 'fzf-plugin'
depends = ['fzf']
hook_source = '''
  let g:fzf_vim = #{
      \   command_prefix: 'Fzf',
      \ }

  " 既に定義されていることがあるので再読み込み
  if exists('g:loaded_fzf_vim')
    unlet g:loaded_fzf_vim
    runtime! plugin/fzf.vim
  endif

  nnoremap <Leader>b <Cmd>FzfBuffers<CR>
  nnoremap <Leader>e <Cmd>FzfFiles<CR>
  nnoremap <Leader>gl <Cmd>FzfGFiles?<CR>
  nnoremap <Leader>mru <Cmd>FzfHistory<CR>
'''
hook_post_source = '''
  " オプションを上書き
  " 上書きする前に読み込まれている必要があるのでautoloadファイル (と依存するpluginファイル)を読み込む
  runtime! plugin/fzf.vim
  call fzf#vim#with_preview()
  function! fzf#vim#with_preview(...) abort
    let spec = a:0 ? copy(a:1) : {}
    let spec.options = get(spec, 'options', []) + ['--no-unicode']
    return spec
  endfunction
'''

[[plugins]]
repo = 'kana/vim-operator-user'

[[plugins]]
repo = 'kana/vim-repeat'
hook_source = '''
  let g:repeat_no_default_key_mappings = 1
'''
hook_post_source = '''
  let g:repeat_no_default_key_mappings = 1
  runtime! plugin/repeat.vim
  RepeatDefaultKeyMappings!
'''

[[plugins]]
repo = 'kana/vim-textobj-indent'
depends = ['textobj-user']
hook_source = '''
  xnoremap it <Plug>(textobj-indent-a)
  onoremap it <Plug>(textobj-indent-a)
  xnoremap at <Plug>(textobj-indent-a)joko
  onoremap at <Plug>(textobj-indent-a)joko
'''

[[plugins]]
repo = 'kana/vim-textobj-user'

[[plugins]]
repo = 'lambdalisue/vim-fern'
hook_source = '''
  call add(g:vimrc#generate_filetypes, 'fern')
  let g:fern#drawer_width = 30

  nnoremap <silent> <Leader>a <Cmd>Fern -drawer -toggle -reveal=% .<CR>
  nnoremap <silent> <Leader>A <Cmd>Fern -drawer -toggle -reveal=% %:h<CR>

  AutocmdFT fern nnoremap <silent><buffer> q <Cmd>bwipeout<CR>
  AutocmdFT fern nnoremap <buffer> h zhg0
  AutocmdFT fern nnoremap <buffer> l zlg0
  AutocmdFT fern nnoremap <silent><buffer> - :<Home>execute "<End>normal \<lt>Plug>(fern-action-mark)"<CR>gj
  AutocmdFT fern nnoremap <buffer><expr> <CR>
      \ fern#smart#leaf(
      \   '<Plug>(fern-action-open)',
      \   '<Plug>(fern-action-expand:stay)',
      \   '<Plug>(fern-action-collapse)',
      \ )
  AutocmdFT fern nnoremap <buffer> <S-CR> <Plug>(fern-action-enter)
  " AutocmdFT fern nnoremap <buffer><nowait> D <Plug>(fern-action-remove)
  AutocmdFT fern nnoremap <buffer> zo <Plug>(fern-action-expand:stay)
  AutocmdFT fern nnoremap <buffer> zO <Plug>(fern-action-expand-tree:stay)
  AutocmdFT fern nnoremap <buffer> zc <Plug>(fern-action-collapse)
  AutocmdFT fern nmap <buffer> <2-LeftMouse> <CR>

  AutocmdFT fern setlocal shiftwidth=1
'''

[[plugins]]
repo = 'lambdalisue/vim-gin'
hook_source = '''
  let g:vimrc#generate_filetypes += [
      \   'gin', 'gin-branch', 'gin-diff', 'gin-edit', 'gin-log', 'gin-status',
      \ ]

  let g:gin_status_default_args = ['++opener=tabnew']
  let g:gin_chaperon_default_args = ['++opener=tabnew']

  function! DiffRevision(commit1, commit2, path)
    " 前提: commit2が新しい
    " commit2 がnullのときworking treeを表示

    if tolower(a:commit1) ==# 'index'
      let commit1 = ''
    else
      let commit1 = a:commit1
    endif
    if tolower(a:commit2) ==# 'index'
      let commit2 = ''
    else
      let commit2 = a:commit2
    endif

    execute 'GinEdit ++opener=tabnew' commit1 fnamemodify(a:path, ':p')
    diffthis
    if a:commit2 is v:null
      botright vsplit `=a:path`
    else
      execute 'GinEdit ++opener=botright\ vsplit' commit2 fnamemodify(a:path, ':p')
    endif
    diffthis
  endfunction

  command! -nargs=* -bang -bar G GinStatus<bang> <args>
  command! -nargs=* -bang -bar GB GinBuffer<bang> <args>
  " command! -nargs=* -bang -bar G GinStatus<bang> ++opener=botright\ 15split <args>
  " command! -nargs=1 -complete=file -bar DiffIndex call DiffRevision('INDEX', v:null, <f-args>)
  " command! -nargs=1 -complete=file -bar DiffStage call DiffRevision('HEAD', 'INDEX', <f-args>)
  command! -nargs=1 -complete=file -bar DiffIndex execute 'GinPatch ++opener=tabnew ++no-head' fnamemodify(<f-args>, ':p') | wincmd l
  command! -nargs=1 -complete=file -bar DiffStage execute 'GinPatch ++opener=tabnew ++no-worktree' fnamemodify(<f-args>, ':p') | wincmd l

  nnoremap <silent> <Leader>gg <Cmd>G<CR>
  nnoremap <silent> <Leader>gd <Cmd>DiffIndex %<CR>
  nnoremap <silent> <Leader>gs <Cmd>DiffStage %<CR>
  nnoremap <expr><silent> <Leader>ga printf('<Cmd>Gin add %s<CR>', expand('%:p'))

  " コミットメッセージ入力時に先頭の行へ移動
  AutocmdFT gitcommit normal! gg

  AutocmdFT gitcommit nnoremap <expr><silent><buffer> <Leader>gd printf('<Cmd>DiffIndex %s/<cfile><CR>', gin#util#worktree())
  AutocmdFT gitcommit nnoremap <expr><silent><buffer> <Leader>gs printf('<Cmd>DiffStage %s/<cfile><CR>', gin#util#worktree())

  Autocmd BufEnter gin*://* setlocal nobuflisted
  Autocmd BufEnter ginedit://*;commitish* setlocal nomodifiable
  " Autocmd BufEnter ginedit://*;commitish* call lsp#disable_diagnostics_for_buffer()

  AutocmdFT gitcommit nnoremap <buffer> <Leader>gl <Cmd>GinStatus ++opener=rightbelow\ split<CR>
  AutocmdFT gin-status nnoremap <buffer> dd <Plug>(gin-action-edit:cached:vsplit)<Cmd>diffthis<CR><C-w>p<Plug>(gin-action-edit:local:edit)<Cmd>diffthis<CR><C-w>x<C-w>w
  AutocmdFT gin-status nnoremap <buffer> ds <Plug>(gin-action-edit:HEAD:vsplit)<Cmd>diffthis<CR><C-w>p<Plug>(gin-action-edit:cached:edit)<Cmd>diffthis<CR><C-w>x<C-w>w

  if !empty(dpp#get('signify'))
    Autocmd User GinCommandPost SignifyRefresh
  endif
'''

[[plugins]]
repo = 'lambdalisue/kensaku.vim'

[[plugins]]
repo = 'lambdalisue/kensaku-command.vim'
depends = ['kensaku']
hook_source = '''
  nnoremap g/ :<C-u>Kensaku<Space>
'''

[[plugins]]
repo = 'lambdalisue/reword.vim'
hook_source = '''
  let g:reword_disable_live = 1

  nnoremap gS :<C-u>%Reword/
  cnoreabbrev <expr> ss Cmdwhen(':', 'ss', 'Reword')
'''

[[plugins]]
repo = 'LumaKernel/ddc-source-file'
depends = ['ddc']

[[plugins]]
repo = 'machakann/vim-vimhelplint'

[[plugins]]
repo = 'mattn/benchvimrc-vim'

[[plugins]]
repo = 'mattn/vim-lsp-settings'
depends = ['lsp']

[[plugins]]
repo = 'mbbill/undotree'
hook_source = '''
  let g:undotree_DiffpanelHeight = 8
  let g:undotree_SetFocusWhenToggle = 1
  let g:undotree_WindowLayout = 2

  nnoremap <Leader>u <Cmd>UndotreeToggle<CR>
'''

[[plugins]]
repo = 'mhinz/vim-signify'
hook_source = '''
  let g:signify_priority = 9
  let g:signify_sign_change = '*'
  let g:signify_skip = { 'vcs': { 'allow': ['git'] } }
  let g:signify_skip_filename_pattern = ['gitgutter://.*']

  let g:signify_vcs_cmds = get(g:, 'signify_vcs_cmds', {})
  let g:signify_vcs_cmds['git'] = 'git diff --no-color --no-ext-diff --ignore-space-change -U0 -- %f'

  " popup のハイライトを上書き
  nnoremap <Leader>gp <Cmd>SignifyHunkDiff<CR><Cmd>sleep 1m <CR><Cmd>call popup_setoptions(popup_locate(screenrow()+1,screencol()),#{highlight:'Normal'})<CR>

  Autocmd OptionSet diff if v:option_new | SignifyDisable | else | SignifyEnable | endif
'''

[[plugins]]
repo = 'prabirshrestha/vim-lsp'
hook_source = '''
  let g:lsp_completion_documentation_enabled = 0
  let g:lsp_diagnostics_echo_cursor = 1
  let g:lsp_diagnostics_highlights_insert_mode_enabled = 0
  " let g:lsp_diagnostics_signs_enabled = 0
  let g:lsp_diagnostics_signs_insert_mode_enabled = 0
  let g:lsp_diagnostics_virtual_text_enabled = 1
  let g:lsp_diagnostics_virtual_text_align = 'after'
  let g:lsp_inlay_hints_enabled = 1
  let g:lsp_hover_ui = 'preview'
  let g:lsp_preview_float = 0
  let g:lsp_preview_keep_focus = 1
  let g:lsp_untitled_buffer_enabled = 0
  let g:lsp_use_native_client = 0

  let g:lsp_diagnostics_signs_error = #{ text: '!' }
  let g:lsp_diagnostics_signs_warning = #{ text: '*' }
  let g:lsp_diagnostics_signs_hint = #{ text: '.' }
  let g:lsp_diagnostics_signs_information = #{ text: '.' }
  let g:lsp_document_code_action_signs_hint = #{ text: ':' }
  let g:lsp_inlay_hints_mode = #{ normal: ['curline'], insert: [] }

  let g:lsp_diagnostics_signs_priority_map = #{
      \   LspError: 12,
      \   LspWarning: 11,
      \ }

  nnoremap <Leader>lh <Plug>(lsp-hover)
  nnoremap <expr><silent> <Leader>ls printf('<Cmd>LspWorkspaceSymbol %s<CR>', expand('<lt>cword>'))
  nnoremap <Leader>lt <Plug>(lsp-peek-type-definition)
  nnoremap <Leader>ll <Plug>(lsp-document-diagnostics)
  nnoremap <Leader>lr <Plug>(lsp-references)
  nnoremap <Leader>lc <Plug>(lsp-code-action)
  nnoremap <Leader>lm <Plug>(lsp-rename)
  xnoremap <silent> <Leader>lc :LspCodeAction<CR>

  " 非同期でカーソルが動くのでスリープを挟む
  nnoremap <silent> <Leader>ld <Plug>(lsp-definition)<Cmd>sleep 1m<CR>zvzz
  nnoremap <silent> <Leader>li <Plug>(lsp-implementation)<Cmd>sleep 1m<CR>zvzz

  Highlight link LspHintText Question
  Highlight link LspInlayHintsType Comment
  Highlight link LspInlayHintsParameter Comment

  function! s:lsp_highlight_virtualtext() abort
    if g:vimrc#is_nvim
      let hl_question = nvim_get_hl(0, #{ name: 'Question' })
      let hl_question_guifg = printf('#%06X', hl_question.fg)
    else
      " 8.2.3578
      let hl_question = hlget('Question', 1)[0]
      let hl_question_guifg = hl_question.guifg
    endif

    highlight LspErrorVirtualText ctermfg=red ctermbg=61 guifg=red guibg=royalblue4
    highlight LspWarningVirtualText ctermfg=yellow ctermbg=61 guifg=yellow2 guibg=royalblue4
    execute 'highlight LspInformationVirtualText'
        \ printf(
        \   'ctermfg=%s ctermbg=61 guifg=%s guibg=royalblue4',
        \   hl_question.ctermfg, hl_question_guifg,
        \ )
    highlight link LspHintVirtualText LspInformationVirtualText
  endfunction
  Autocmd ColorScheme * call <SID>lsp_highlight_virtualtext()

  " 重いことがあるので一旦無効化
  " Autocmd User lsp_buffer_enabled
  "    \ if &filetype !=# 'vim' |
  "    \   setlocal foldmethod=expr |
  "    \ endif
  " Autocmd User lsp_buffer_enabled setlocal foldexpr=lsp#ui#vim#folding#foldexpr()
  " Autocmd User lsp_buffer_enabled setlocal foldtext=lsp#ui#vim#folding#foldtext()
  Autocmd User lsp_buffer_enabled setlocal signcolumn=yes
  AutocmdFT lsp-hover noremap <buffer><silent> q <Cmd>bwipeout<CR>
  Autocmd OptionSet diff
      \ if v:option_new |
      \   call lsp#disable_diagnostics_for_buffer() |
      \ else |
      \   call lsp#enable_diagnostics_for_buffer() |
      \ endif

  " inlay表示でカーソル位置がずれるので
  " https://github.com/vim/vim/issues/12769
  if !has('patch-9.0.1851')
    Autocmd User lsp_buffer_enabled setlocal nobreakindent breakindentopt= showbreak=NONE
  endif

  if g:vimrc#is_nvim
    Autocmd User lsp_float_opened
        \ if lsp#document_hover_preview_winid() isnot v:null |
        \   call nvim_win_set_option(
        \     lsp#document_hover_preview_winid(),
        \     'winhighlight',
        \     'MatchParen',
        \   ) |
        \ endif
  else
    Autocmd User lsp_float_opened
        \ if lsp#document_hover_preview_winid() isnot v:null |
        \   call setwinvar(
        \     lsp#document_hover_preview_winid(),
        \     '&wincolor',
        \     'MatchParen',
        \   ) |
        \ endif
  endif
'''

[[plugins]]
repo = 'preservim/vim-indent-guides'
hook_source = '''
  let g:indent_guides_auto_colors = 1
  let g:indent_guides_default_mapping = 0
  let g:indent_guides_enable_on_vim_startup = 1
  let g:indent_guides_exclude_filetypes = ['help', 'diff', 'fugitive']
  let g:indent_guides_indent_levels = 15
  let g:indent_guides_start_level = 1

  " Highlight link IndentGuidesOdd Comment
  " Highlight link IndentGuidesEven Folded

  Autocmd OptionSet shiftwidth
      \ if g:indent_guides_autocmds_enabled | call indent_guides#enable() | endif
'''

[[plugins]]
repo = 'rbtnn/vim-ambiwidth'

[[plugins]]
repo = 'rhysd/conflict-marker.vim'
hook_source = '''
  let g:conflict_marker_enable_mapping = 0
  let g:conflict_marker_highlight_group = ''
  let g:conflict_marker_hooks = #{ on_detected: expand('<SID>') .. 'conflict_marker_on_detected' }

  Highlight link ConflictMarkerBegin Error
  Highlight link ConflictMarkerEnd Error
  Highlight link ConflictMarkerOurs DiffDelete
  Highlight link ConflictMarkerCommonAncestors Error
  Highlight link ConflictMarkerCommonAncestorsHunk Folded
  Highlight link ConflictMarkerTheirs DiffAdd

  function! s:conflict_marker_on_detected() abort
    nnoremap <buffer> ]x <Plug>(conflict-marker-next-hunk)
    nnoremap <buffer> [x <Plug>(conflict-marker-prev-hunk)
  endfunction
'''
hook_post_source = '''
  " 読み込まれてないときがある？
  runtime! plugin/conflict_marker.vim
  autocmd ConflictMarkerDetect BufEnter * doautocmd ConflictMarkerDetect BufRead
'''

[[plugins]]
repo = 'rhysd/vim-operator-surround'
depends = ['operator-user']
hook_source = '''
  nnoremap s <Plug>(operator-surround-append)
  xnoremap s <Plug>(operator-surround-append)
  nnoremap ds <Plug>(operator-surround-delete)a
  nnoremap dsi <Plug>(operator-surround-delete)i
  nnoremap cs <Plug>(operator-surround-replace)a
  nnoremap csi <Plug>(operator-surround-replace)i
'''

[[plugins]]
repo = 'rhysd/vim-textobj-word-column'
depends = ['textobj-user']

[[plugins]]
repo = 'ronakg/quickr-preview.vim'
hook_source = '''
  " let g:quickr_preview_position = 'above'
  " let g:quickr_preview_keymaps = 0
  let g:quickr_preview_line_hl = 'CursorLine'
  let g:quickr_preview_on_cursor = 0
  let g:quickr_preview_open = 1
  let g:quickr_preview_options = 'cursorline nofoldenable nolist nonumber norelativenumber scrolloff=999'

  AutocmdFT qf let b:prvlinenr = 0
  AutocmdFT qf
      \ nnoremap <silent><buffer> p
      \   <Plug>(quickr_preview):let g:quickr_preview_open = !g:quickr_preview_open<CR>
  AutocmdFT qf
      \ nnoremap <silent><buffer> <CR>
      \   <Cmd>call ClosePreviewWindow()<CR><CR>zv
  AutocmdFT qf
      \ nnoremap <expr><silent><buffer> <C-j>
      \   g:quickr_preview_open ? '<Cmd>set eventignore+=CursorMoved lazyredraw<CR><C-w>P' .. v:count .. '<C-e><C-w>p:set eventignore-=CursorMoved nolazyredraw<CR>' : ''
  AutocmdFT qf
      \ nnoremap <expr><silent><buffer> <C-k>
      \   g:quickr_preview_open ? '<Cmd>set eventignore+=CursorMoved lazyredraw<CR><C-w>P' .. v:count .. '<C-y><C-w>p:set eventignore-=CursorMoved nolazyredraw<CR>' : ''
  AutocmdFT qf Autocmd CursorMoved <buffer>
      \ if g:quickr_preview_open && exists('*QFMove') |
      \   let b:prvlinenr = 0 |
      \   call QFMove(line('.')) |
      \ endif
  AutocmdFT qf doautocmd CursorMoved
  AutocmdFT qf execute 'Autocmd WinClosed' win_getid() 'call ClosePreviewWindow()'
  Autocmd BufEnter,WinEnter,BufLeave,WinLeave setglobal modifiable&
'''

[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'Shougo/ddc.vim'
hook_post_source = '''
  call ddc#custom#set_global({})
  call ddc#custom#patch_global('sources', ['vim-lsp', 'around', 'window'])

  if !empty(dpp#get('pum')) && !empty(dpp#get('ddc-ui-pum'))
    let g:ddc_display_ui = 'pum'
  else
    let g:ddc_display_ui = 'native'
  endif
  call ddc#custom#patch_global('ui', 'none')
  " call ddc#custom#patch_global('ui', g:ddc_display_ui)

  call ddc#custom#patch_filetype('vim', 'sources', ['necovim', 'around', 'window'])
  call ddc#custom#patch_filetype('vim', 'sourceParams', #{
      \   window: #{
      \     include_filetypes: ['help'],
      \   },
      \ })

  call ddc#custom#patch_global('sourceOptions', #{
      \   _: #{
      \     dup: 'keep',
      \     matchers: ['matcher_head'],
      \     sorters: ['sorter_rank'],
      \     ignoreCase: v:true,
      \     minAutoCompleteLength: 1,
      \     timeout: 5000,
      \   },
      \   around: #{
      \     mark: 'A',
      \     minAutoCompleteLength: 2,
      \   },
      \   line: #{
      \     mark: 'line',
      \   },
      \   vim-lsp: #{
      \     mark: 'L',
      \     forceCompletionPattern: '(::|->|\.)\w*',
      \     minAutoCompleteLength: 0,
      \     sorters: ['sorter_rank', 'sorter_ascii'],
      \   },
      \   file: #{
      \     sorters: ['sorter_ascii'],
      \     forceCompletionPattern: '/',
      \     isVolatile: v:true,
      \   },
      \   necovim: #{
      \     mark: 'vim',
      \     sorters: ['sorter_rank', 'sorter_ascii'],
      \     minAutoCompleteLength: 0,
      \   },
      \   neosnippet: #{ mark: 'snip' },
      \   window: #{
      \     mark: 'win',
      \     minAutoCompleteLength: 2,
      \     keywordPattern: '\w+',
      \   },
      \ })
  call ddc#custom#patch_global('sourceParams', #{
      \   around: #{
      \     maxSize: 500,
      \   },
      \   file: #{
      \     displayCwd: 'c',
      \     displayBuf: 'b',
      \     filenameChars: '\-@.[:alnum:]_~',
      \   },
      \ })

  if !empty(dpp#get('skkeleton'))
    function! s:skkeleton_enable()
      if !exists('b:ddc_options')
        " skkeleton有効時の設定が入ることがあるので初回だけ
        let b:ddc_options = ddc#custom#get_buffer()

        " preview 外すと機能しなくなるので一旦無効化
        " let b:save_cot = &completeopt
        " set completeopt-=preview
      endif

      call ddc#custom#set_buffer(#{
          \   ui: g:ddc_display_ui,
          \   sources: ['skkeleton', 'around'],
          \   sourceOptions: #{
          \     _: #{
          \       sorters: [],
          \       matchers: [],
          \     },
          \   },
          \ })
    endfunction
    Autocmd User skkeleton-enable-pre call <SID>skkeleton_enable()

    function! s:skkeleton_disable()
      call ddc#custom#set_buffer(b:ddc_options)
      " let &completeopt = b:save_cot
    endfunction
    Autocmd User skkeleton-disable-pre call <SID>skkeleton_disable()

    call ddc#custom#patch_global('sourceOptions', #{
        \   skkeleton: #{
        \     mark: 'SKK',
        \     matchers: [],
        \     sorters: [],
        \     converters: [],
        \     minAutoCompleteLength: 1,
        \     isVolatile: v:true,
        \   },
        \ })
  endif

  call ddc#enable(#{ context_filetype: 'context_filetype' })

  inoremap <silent><expr> <C-n> pumvisible() ? '<Plug>(vimrc_complete-next)' : '<Plug>(vimrc_complete-manual_complete)'
  inoremap <silent><expr> <C-p> pumvisible() ? '<Plug>(vimrc_complete-prev)' : '<Plug>(vimrc_complete-manual_complete)'
  inoremap <silent><expr> <Plug>(vimrc_complete-manual_complete) ddc#map#complete(g:ddc_display_ui)
  inoremap <silent><expr> <Plug>(vimrc_complete-file)
      \ ddc#map#manual_complete(#{
      \   sources: ['file'], ui: g:ddc_display_ui,
      \ })
  inoremap <C-l> <Nop>
  inoremap <silent><expr> <C-l>s
      \ ddc#map#manual_complete(#{
      \   sources: ['neosnippet'], ui: g:ddc_display_ui,
      \ })
  inoremap <silent><expr> <C-l>l
      \ ddc#map#manual_complete(#{
      \   sources: ['line'], ui: g:ddc_display_ui,
      \ })
  " imap <C-Space> <C-n>

  Autocmd InsertLeave * if !IsCommandLineWindow() | pclose | endif
'''

[[plugins]]
repo = 'Shougo/ddc-filter-matcher_head'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/ddc-filter-sorter_rank'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/ddc-source-around'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/ddc-source-line'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/ddc-ui-native'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/ddc-ui-none'
depends = ['ddc']

# [[plugins]]
# repo = 'Shougo/ddc-ui-pum'
# depends = ['ddc', 'pum']

[[plugins]]
repo = 'Shougo/dpp.vim'
if = '(0)'

[[plugins]]
repo = 'Shougo/dpp-ext-installer'
depends = ['dpp']
if = '(0)'

[[plugins]]
repo = 'Shougo/dpp-ext-toml'
depends = ['dpp']
if = '(0)'

[[plugins]]
repo = 'Shougo/dpp-protocol-git'
depends = ['dpp']
if = '(0)'

[[plugins]]
repo = 'Shougo/neco-vim'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/neosnippet.vim'
depends = ['neosnippet-snippets', 'ddc']
hook_source = '''
  let g:neosnippet#disable_select_mode_mappings = 0
  let g:neosnippet#enable_auto_clear_markers = 0
  " let g:neosnippet#enable_completed_snippet = 1
  " let g:neosnippet#enable_complete_done = 1

  snoremap <expr> <Tab> neosnippet#jumpable() ?
     \ '<Esc>a<Plug>(neosnippet_jump)' : '<Plug>(vimrc_tab)'
  inoremap <expr> <Tab>
      \ pumvisible() ?
      \   neosnippet#expandable_or_jumpable() ? '<Plug>(neosnippet_expand_or_jump)' : '' :
      \   neosnippet#jumpable() ? '<Plug>(neosnippet_jump)' : '<Plug>(vimrc_tab)'
  " neosnippet がソースになくても同名の候補でスニペットが展開されるのでv:completed_itemを見て展開しないようにする
  inoremap <expr> <CR>
      \ pumvisible() ?
      \   get(v:completed_item, 'menu', '') =~# '^snip\>' && neosnippet#expandable() ?
      \     '<Plug>(neosnippet_expand)' : '<Plug>(vimrc_complete-confirm)' : '<Plug>(vimrc_cr)'
  snoremap <silent> <CR> <C-r>"a<BS><C-r>"
  snoremap <silent> <BS> <C-r>_a<BS>

  Autocmd InsertLeave * NeoSnippetClearMarkers
  " Autocmd User lsp_complete_done call neosnippet#complete_done()

  if has('conceal')
    set conceallevel=2 concealcursor=iv
  endif
'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'
merged = 0
hook_source = '''
  let g:neosnippet#snippets_directory = dpp#get('neosnippet-snippets').path .. '/neosnippet'
'''

# [[plugins]]
# repo = 'Shougo/pum.vim'
# hook_source = '''
#   " WIP
#   inoremap <expr> <Plug>(vimrc_complete-next) pum#visible() ? pum#map#insert_relative(1, 'loop') : ''
#   inoremap <expr> <Plug>(vimrc_complete-prev) pum#visible() ? pum#map#insert_relative(-1, 'loop') : ''
# '''
# hook_post_source = '''
#   " WIP
#   call pum#set_option(#{
#       \ })
# '''

[[plugins]]
repo = 'shun/ddc-source-vim-lsp'
depends = ['ddc', 'lsp']

[[plugins]]
repo = 'skk-dev/dict'
name = 'skk-dict'
merged = 0
hook_source = '''
  let s:skk_dict_dir = dpp#get('skk-dict').path
'''

[[plugins]]
repo = 'thinca/vim-ft-help_fold'
name = 'help-fold'

[[plugins]]
repo = 'thinca/vim-partedit'
hook_source = '''
  let g:partedit#opener = 'split'

  function! OpenContext() abort
    " ex. {'filetype': 'vim', 'range': [[1114, 1], [1128, 90]]}
    let context = context_filetype#get()
    let ft = context.filetype
    let lines = [context.range[0][0], context.range[1][0]]

    call partedit#start(lines[0], lines[1], #{ filetype: ft })
    nnoremap <silent><buffer> <Leader>p <Cmd>ParteditEnd<CR><C-w>c

    if !empty(dpp#get('ddc'))
      call ddc#custom#patch_buffer('specialBufferCompletion', v:true)
    endif
    if !empty(dpp#get('lightline'))
      call lightline#update()
    endif
  endfunction

  Autocmd BufReadPost dpp.toml,dpp/*.toml let b:partedit_filetype = 'vim'
  Autocmd BufReadPost dpp.toml,dpp/*.toml let b:partedit_prefix = '\s*'
  AutocmdFT markdown,toml nnoremap <silent><buffer> <Leader>p <Cmd>call OpenContext()<CR>
'''

[[plugins]]
repo = 'thinca/vim-prettyprint'

[[plugins]]
repo = 'thomasfaingnaert/vim-lsp-snippets'
depends = ['lsp']

[[plugins]]
repo = 'thomasfaingnaert/vim-lsp-neosnippet'
depends = ['lsp', 'neosnippet']

[[plugins]]
repo = 'tyru/caw.vim'
depends = ['operator-user', 'repeat']
hook_source = '''
  let g:caw_dollarpos_sp_left = ' '
  let g:caw_hatpos_align = 1
  let g:caw_hatpos_skip_blank_line = 1
  " let g:caw_no_default_keymappings = 1
  let g:caw_operator_keymappings = 1

  AutocmdFT haskell let b:caw_wrap_oneline_comment = ['{-', '-}']
  AutocmdFT haskell let b:caw_wrap_multiline_comment = #{ left: '{-', right: '-}', top: '-', bottom: '-' }

  " nnoremap <silent><expr> <Leader>cc '<C-c>V' .. (v:count <= 1 ? 'V' : v:count - 1 .. 'gj') .. '<Plug>(caw:hatpos:toggle)'
  nnoremap <Leader>cc <Plug>(caw:hatpos:toggle)
  xnoremap <Leader>cc <Plug>(caw:hatpos:toggle)
  noremap <silent> <Leader>ct :normal 1 cc<CR>
  sunmap <Leader>ct
  ounmap <Leader>ct

  nnoremap <Leader>cu <Plug>(caw:hatpos:uncomment)
  xnoremap <Leader>cu <Plug>(caw:hatpos:uncomment)
  nnoremap <Leader>cd <Plug>(caw:hatpos:toggle:operator)
  nnoremap <Leader>ca <Plug>(caw:dollarpos:toggle)
  nnoremap <Leader>cw <Plug>(caw:wrap:toggle:operator)
  xnoremap <Leader>cw <Plug>(caw:wrap:toggle)
  nnoremap <Leader>co <Plug>(caw:jump:comment-next)
  nnoremap <Leader>cO <Plug>(caw:jump:comment-prev)
'''

[[plugins]]
repo = 'tyru/operator-camelize.vim'
hook_source = '''
  nnoremap sc <Plug>(operator-camelize-toggle)
'''

[[plugins]]
repo = 'vim-denops/denops.vim'
if = '(0)'

[[plugins]]
repo = 'vim-jp/vimdoc-ja'

[[plugins]]
repo = 'vim-skk/skkeleton'
hook_source = '''
  noremap! ,, <Plug>(skkeleton-enable)

  function! s:skk_init()
    call skkeleton#config(#{
        \   eggLikeNewline: v:true,
        \   globalDictionaries: [s:skk_dict_dir .. '/SKK-JISYO.L'],
        \   keepState: v:true,
        \   markerHenkan: '',
        \   markerHenkanSelect: '',
        \ })
    call skkeleton#register_kanatable('rom', #{
        \   jk: 'escape',
        \ })
    call skkeleton#register_keymap('input', ';', 'henkanPoint')

    call remove(g:skkeleton#mapped_keys, index(g:skkeleton#mapped_keys, '<Down>'))
    call remove(g:skkeleton#mapped_keys, index(g:skkeleton#mapped_keys, '<Up>'))
  endfunction
  Autocmd User skkeleton-initialize-pre call <SID>skk_init()
'''

[[plugins]]
repo = 'yasunori0418/statusline_skk.vim'
depends = ['skkeleton']
hook_post_source = '''
  call statusline_skk#option('display', #{
      \   hiragana: 'あ',
      \   katakana: 'ア',
      \   hankaku_katakana: 'ｱ ',
      \   zenkaku_alphabet: 'Ａ',
      \   alphabet: 'a ',
      \   abbrev: 'ab',
      \ })
'''

[[plugins]]
repo = 'yuki-yano/fuzzy-motion.vim'
hook_source = '''
  if !empty(dpp#get('kensaku'))
    let g:fuzzy_motion_matchers = ['fzf', 'kensaku']
  endif

  nnoremap <silent> <Leader>f <Cmd>FuzzyMotion<CR>
'''


[[plugins]]
repo = 'equalsraf/neovim-gui-shim'
if = 'g:vimrc#is_nvim'

[[plugins]]
repo = 'smoka7/hop.nvim'
if = 'g:vimrc#is_nvim'
hook_source = '''
  nnoremap <silent> <Leader><Leader>w <Cmd>HopWord<CR>
  nnoremap <silent> <Leader><Leader>j <Cmd>HopLineStart<CR>
  nnoremap <silent> <Leader><Leader>f <Cmd>HopChar1<CR>
  nnoremap <silent> <Leader><Leader>n <Cmd>call v:lua.require('hop').hint_patterns({}, @/)<CR>
'''
lua_post_source = '''
  require'hop'.setup {
    keys = 'fjdkslaghrueiwoqptyvmcxzbn',
  }
'''

[[plugins]]
repo = 'monkoose/vim9-stargate'
if = '!g:vimrc#is_nvim'
hook_source = '''
  let g:stargate_chars = 'fjdkslaghrueiwoqptyvmcxzbn'
  let g:stargate_limit = 2000

  nnoremap <Leader><Leader>w <Cmd>call stargate#OKvim('\<')<CR>
  nnoremap <Leader><Leader>j <Cmd>call stargate#OKvim('\_^\s*\zs\S')<CR>
  nnoremap <Leader><Leader>f <Cmd>call stargate#OKvim(1)<CR>
  nnoremap <Leader><Leader>n <Cmd>call stargate#OKvim(@/)<CR>
'''

[[plugins]]
repo = 'mattn/vimtweak'
if = '!g:vimrc#is_nvim && g:vimrc#is_windows && g:vimrc#is_gui'

