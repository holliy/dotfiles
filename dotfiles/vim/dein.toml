[[plugins]]
repo = 'bkad/CamelCaseMotion'
hook_source = '''
noremap gw <Plug>CamelCaseMotion_w
noremap gb <Plug>CamelCaseMotion_b
noremap ge <Plug>CamelCaseMotion_e
sunmap gw
sunmap gb
sunmap ge

onoremap icw <Plug>CamelCaseMotion_iw
xnoremap icw <Plug>CamelCaseMotion_iw
onoremap icb <Plug>CamelCaseMotion_ib
xnoremap icb <Plug>CamelCaseMotion_ib
onoremap ice <Plug>CamelCaseMotion_ie
xnoremap ice <Plug>CamelCaseMotion_ie
'''

[[plugins]]
repo = 'cohama/lexima.vim'
hook_source = '''
  let g:lexima_map_escape = 'jk'
  " let g:lexima_accept_pum_with_enter = 1

  inoremap <expr><silent> <Plug>(vimrc_cr) lexima#expand('<lt>CR>', 'i')
  inoremap <expr><silent> <Plug>(vimrc_tab) lexima#expand('<lt>TAB>', 'i')

  if g:vimrc#is_nvim
    Autocmd TermOpen * let b:lexima_disabled = 1
  elseif has('terminal')
    Autocmd TerminalWinOpen * let b:lexima_disabled = 1
  endif
'''
hook_post_source = '''
  let save_cr_mapping = maparg('<CR>', 'i', 0, 1)
  let save_tab_mapping = maparg('<Tab>', 'i', 0, 1)

  let quotes = [
      \   #{ start: "'", end: "'" }, #{ start: '"', end: '"' }
      \ ]
  let brackets = [
      \   #{ start: '(', end: ')' }, #{ start: '{', end: '}' },
      \   #{ start: '[', end: ']' }
      \ ]
  let comments = [
      \   #{
      \     start: '/*', end: '*/', head: '*',
      \     filetype: ['c', 'cpp', 'cs', 'java', 'rust', 'scala']
      \   },
      \   #{ start: '{-', end: '-}', with_bracket: 1, filetype: ['haskell'] },
      \   #{ start: '{-#', end: '#-}', filetype: ['haskell'] },
      \ ]

  " call filter(g:lexima#default_rules,
  "    \ { _, v -> !has_key(v, 'at') || v.at !=# '\\\%#' })
  call lexima#set_default_rules()

  " quote in lisp "{{{
  call lexima#add_rule(#{
      \   char: "'",
      \   filetype: ['lisp', 'scheme']
      \ })
  call lexima#add_rule(#{
      \   char: "'",
      \   input_after: "'",
      \   filetype: ['lisp', 'scheme'],
      \   syntax: ['Comment', 'Constant', 'String']
      \ })
  call lexima#add_rule(#{
      \   at: "\\%#'",
      \   char: "'",
      \   leave: 1,
      \   filetype: ['lisp', 'scheme'],
      \   syntax: ['Comment', 'Constant', 'String']
      \ })
  "}}}

  " comment "{{{
  for c in comments
    call lexima#add_rule(#{
        \   at: '\V' .. c.start[:-2] .. '\%#\$',
        \   char: c.start[-1:],
        \   input_after: c.end,
        \   filetype: c.filetype
        \ })
    call lexima#add_rule(#{
        \   at: '\V' .. c.start .. '\%#' .. c.end,
        \   char: '<Space>',
        \   input_after: '<Space>',
        \   filetype: c.filetype
        \ })
    call lexima#add_rule(#{
        \   at: '\V' .. c.start .. '\%#' .. c.end,
        \   char: '<BS>',
        \   input: repeat('<BS>', len(c.start)),
        \   delete: len(c.end),
        \   filetype: c.filetype
        \ })
    call lexima#add_rule(#{
        \   at: '\V' .. c.start .. ' \%# ' .. c.end,
        \   char: '<BS>',
        \   delete: 1,
        \   filetype: c.filetype
        \ })

    if has_key(c, 'head')
      call lexima#add_rule(#{
          \   at: '\V\^ ' .. c.head .. ' \%# \?' .. c.end,
          \   char: '<BS>',
          \   input: '<BS><BS>',
          \   filetype: c.filetype
          \ })
      call lexima#add_rule(#{
          \   at: '^ \%#',
          \   char: '<Space>',
          \   input: c.head .. '<Space>',
          \   filetype: c.filetype,
          \   syntax: ['Comment']
          \ })
    endif

    if get(c, 'with_bracket', 0)
      call lexima#add_rule(#{
          \   at: '\V' .. c.start[:-2] .. '\%#' .. c.end[1:] .. '\$',
          \   char: c.start[-1:],
          \   input_after: c.end[:0],
          \   filetype: c.filetype
          \ })
    endif
  endfor "}}}

  " bracket "{{{
  for pair in brackets
    call lexima#add_rule(#{
        \   at: '\V' .. pair.start .. '\%#' .. pair.end,
        \   char: '<CR>',
        \   input: '<CR>\ ',
        \   input_after: '<CR>\ ',
        \   filetype: ['vim']
        \ })
    " カッコの間に改行を入力時、継続行にして3行に展開
    call lexima#add_rule(#{
        \   at: pair.start .. '\%#$',
        \   except: '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s*\\.*)\n)*\1\s*\\\s*\' .. pair.end,
        \   char: '<CR>',
        \   input: '<CR>\ ',
        \   input_after: '<CR>\ ' .. pair.end,
        \   filetype: ['vim']
        \ })
    " ↑の展開後の途中の改行でも行継続
    call lexima#add_rule(#{
        \   at: '\C\v^(\s*)\S.*\' .. pair.start .. '%#\n%(%(\s*|\1\s*\\.*)\n)*\1\s*\\\s*\' .. pair.end,
        \   char: '<CR>',
        \   input: '<CR>\ ',
        \   filetype: ['vim']
        \ })
    call lexima#add_rule(#{
        \   at: '\%#\w',
        \   char: pair.start
        \ })
  endfor

  call lexima#add_rule(#{
      \   at: '\\%\?\%#',
      \   char: '(',
      \   input_after: '\)',
      \   filetype: ['vim']
      \ })
  "}}}

  call lexima#add_rule(#{
      \   at: '^\s*\\\(\s*\).\{-}\%#',
      \   char: '<CR>',
      \   input: '<CR>\\\1',
      \   with_submatch: 1,
      \   filetype: ['vim']
      \ })

  " 補完した文字の後ろに<Tab>で移動 "{{{
  for pair in brackets + quotes
    call lexima#add_rule(#{
        \   at: '\V\%#\( \?\|\n\s\*\)' .. pair.end,
        \   char: '<Tab>',
        \   leave: pair.end
        \ })
  endfor

  for c in comments
    call lexima#add_rule(#{
        \   at: '\V\S\%# \?' .. c.end,
        \   char: '<Tab>',
        \   leave: c.end,
        \   filetype: c.filetype,
        \   syntax: ['Comment']
        \ })
  endfor

  call lexima#add_rule(#{
      \   at: '\%#\\)',
      \   char: '<Tab>',
      \   leave: '\\)',
      \   filetype: ['vim']
      \ })
  "}}}

  " prehook for neosnippet "{{{
  " 補完メニューを開いている間に入力したときにleximaのマッピングの途中でCompleteDoneが発火してそう
  " 先にCompleteDoneを処理させると選択モードになる場合があって<C-]>が誤爆するので適当に入力して選択モードを抜ける
  for char in keys(lexima#insmode#get_rules())
    execute printf(
        \   "inoremap <expr><silent> %s (pumvisible() ? '<C-y>a<BS>' : '') .. lexima#expand(%s, 'i')",
        \   char,
        \   string(lexima#string#to_mappable(char))
        \ )
  endfor "}}}

  " inoremap <expr><silent> <CR> pumvisible() ? '<Plug>(vimrc_complete-confirm)' : '<Plug>(vimrc_cr)'
  if !empty(save_cr_mapping)
    call mapset('i', 0, save_cr_mapping)
  endif
  if !empty(save_tab_mapping)
    call mapset('i', 0, save_tab_mapping)
  endif
'''

# [[plugins]]
# repo = 'derekwyatt/vim-scala'
# on_ft = 'scala'

# [[plugins]]
# repo = 'eagletmt/ghcmod-vim'
# on_ft = 'haskell'
# hook_source = '''
#   Autocmd Filetype haskell nnoremap <buffer><silent> <Leader>ft :<C-u>GhcModType!<CR>
#   Autocmd Filetype haskell nnoremap <buffer><silent> <Leader>fi :<C-u>GhcModInfo!<CR>
#   Autocmd Filetype haskell nnoremap <buffer><silent> <Leader><Tab> :<C-u>nohlsearch<Bar>GhcModTypeClear<CR>
#   Autocmd Filetype haskell nnoremap <buffer><silent> <Leader>fc :<C-u>GhcModCheckAsync<CR>
#   Autocmd Filetype haskell nnoremap <buffer><silent> <Leader>fl :<C-u>GhcModLintAsync<CR>
# '''

# [[plugins]]
# repo = 'eagletmt/neco-ghc'
# on_ft = 'haskell'

[[plugins]]
repo = 'editorconfig/editorconfig-vim'
hook_source = '''
  " バッファ作成時にmodifiedになるので一旦無効化
  " let g:EditorConfig_enable_for_new_buf = 1
'''
hook_post_source = '''
  function! s:editorconfig_enabled(config) abort
    if has_key(a:config, 'charset')
      let value = a:config.charset

      execute 'set fileencodings-=' .. value
      execute 'set fileencodings^=' .. value

      let &g:fileencoding = value
    endif

    if has_key(a:config, 'end_of_line')
      let mapping = #{ lf: 'unix', cr: 'mac', crlf: 'dos' }
      let value = mapping[a:config.end_of_line]

      execute 'set fileformats-=' .. value
      execute 'set fileformats^=' .. value

      let &g:fileformat = value
    endif

    return 0
  endfunction

  call editorconfig#AddNewHook(function('s:editorconfig_enabled'))
'''

[[plugins]]
repo = 'gamoutatsumi/ddc-sorter_ascii'
depends = ['ddc']

[[plugins]]
repo = 'itchyny/landscape.vim'
hook_post_source = '''
  colorscheme landscape
  doautocmd ColorScheme
'''

[[plugins]]
repo = 'itchyny/lightline.vim'
hook_source = '''
  " g:lightline "{{{
  let g:lightline = #{
      \   enable: #{
      \     statusline: 1,
      \     tabline: 1,
      \   },
      \   colorscheme: 'landscape',
      \   active: #{
      \     left: [['mode', 'paste', 'skk'], ['bufnum', 'git', 'directory', 'filename', 'readonly', 'modified'], ['showcmd']],
      \     right: [['trailing', 'lineinfo'], ['percent'], ['truncate', 'fileinfo', 'filetype']]
      \   },
      \   inactive: #{
      \     left: [['bufnum', 'git', 'directory', 'filename', 'readonly', 'modified']],
      \     right: [['lineinfo'], ['percent']]
      \   },
      \   tabline: #{
      \     left: [['buffers']],
      \     right: [['close']]
      \   },
      \   tab: #{
      \     active: ['tabnum', 'filename', 'modified'],
      \     inactive: ['bufnum', 'filename', 'modified'],
      \   },
      \   component: #{
      \     close: '%999X x ',
      \     lineinfo: "L %3l:%-2v",
      \     paste: '%{&paste?"P":""}',
      \     percent: '%4P',
      \     showcmd: exists('+showcmdloc') ? '%S' : '',
      \     truncate: '%<'
      \   },
      \   component_visible_condition: #{
      \     truncate: '0'
      \   },
      \   component_function: #{
      \     git: 'LightlineGit',
      \     directory: 'LightlineDirectory',
      \     filename: 'LightlineFilename',
      \     fileinfo: 'LightlineFileinfo',
      \     filetype: 'LightlineFiletype',
      \     mode: 'LightlineMode',
      \     modified: 'LightlineModified',
      \     readonly: 'LightlineReadonly'
      \   },
      \   component_expand: #{
      \     buffers: 'LightlineBuffers',
      \     trailing: 'LightlineTrailingSpaceWarning'
      \   },
      \   component_function_visible_condition: #{
      \     directory: '&filetype!=#"netrw"'
      \   },
      \   component_type: #{
      \     buffers: 'tabsel',
      \     trailing: 'error'
      \   },
      \   tab_component_function: #{
      \     bufnum: 'lightline#tab#tabnum',
      \     filename: 'LightlineFilenameB',
      \     modified: 'LightlineModified',
      \     tabnum: 'LightlineTabnum'
      \   },
      \   separator: #{ left: "", right: "" },
      \ }

  " 使うけど'statusline'を自動で設定されたくないので
  let g:lightline.enable.statusline = 0

  if g:vimrc#is_windows && g:vimrc#is_gui
    let g:lightline.subseparator = #{ left: "|", right: "|" }
  else
    let g:lightline.subseparator = #{ left: "│", right: "│" }
  endif

  if dein#is_available('lightline_skk')
    let g:lightline.component_function['skk'] = 'lightline_skk#mode'
  endif
  "}}}

  " タブラインにバッファ一覧を表示 "{{{
  function! LightlineBuffers() abort "{{{
    " return:タブが5個以上の時ウィンドウの幅によって5個から17個表示する
    let [active_bn, alt_bn, last_bn, tn] = [bufnr(), winbufnr(winnr('#')), bufnr('$'), tabpagenr()]
    let [left, mid, right] = [[], [], []]
    let fold = '...'
    let max_side_tabs = min([max([&columns/50, 2]), 8]) " left, rightそれぞれから表示する数

    if IgnoreBuffer(active_bn)
      if !IgnoreBuffer(alt_bn)
        let active_bn = alt_bn
      else
        " タブページ内のウィンドウから探す
        for bn in tabpagebuflist()
          if !IgnoreBuffer(bn)
            let active_bn = bn
            break
          endif
        endfor
      endif
    endif

    for binfo in getbufinfo(#{ buflisted: 1 })
      let bn = binfo.bufnr
      if bn ==# active_bn
        call add(mid, printf('%%%dT%%{lightline#onetab(%d, 1)}', tn, bn))
        continue
      endif

      if IgnoreBuffer(bn)
        continue
      endif

      call add(bn < active_bn ? left : right, printf('%%%dT%%{lightline#onetab(%d, 0)}', tn, bn) .. (bn ==# last_bn ? '%T' : ''))
    endfor

    let left_len = len(left)
    let right_len = len(right)
    if left_len + right_len > max_side_tabs*2
      " let max_left_tabs = max([left_len])
      if left_len > max_side_tabs
        let left = [fold] + left[-max_side_tabs:]
      endif

      if right_len > max_side_tabs
        let right = right[:max_side_tabs - 1] + [fold]
      endif
    endif
    return [left, mid, right]
  endfunction "}}}

  " 更新されないので再度セットすることで更新
  Autocmd BufAdd,BufDelete * execute 'set tabline=' .. &tabline
  "}}}

  function! LightlineModified(bn = 0) abort "{{{
    let bn = a:bn
    if bn ==# 0
      let bn = bufnr()
    endif

    return getbufvar(bn, '&modified') ? '+' :
        \ IgnoreBuffer(bn) ? '' :
        \ getbufvar(bn, '&filetype') =~# 'netrw' ? '' :
        \ getbufvar(bn, '&modifiable') ? '' : '-'
  endfunction "}}}

  function! LightlineFilenameB(bufnr) abort "{{{
    let l:fname = fnamemodify(bufname(a:bufnr), ':t')
    let l:alt_fname = fnamemodify(bufname(0), ':t')
    return IsCommandLineWindow(a:bufnr) ? l:alt_fname :
        \ empty(l:fname) ? gettext('[No Name]') : l:fname
  endfunction "}}}

  function! LightlineTabnum(_ = v:none) abort "{{{
    return tabpagenr()
  endfunction "}}}

  let s:readonlychar = 'x'
  function! LightlineReadonly() abort "{{{
    return IgnoreBuffer() ? '' :
        \ &filetype =~# 'netrw' ? '' :
        \ &readonly ? s:readonlychar : ''
  endfunction "}}}

  function! LightlineFilename() abort "{{{
    if &filetype ==# 'netrw'
      let save_shellslash = &shellslash
      set shellslash

      let curdir = fnamemodify(b:netrw_curdir, ':~:.:s?[^/]\zs$?/?')

      let &shellslash = save_shellslash
      return curdir
    else
      let l:fname = expand('%:t')
      return IsCommandLineWindow() ? '' :
          \ &filetype ==# 'qf' ?
          \   win_gettype() ==# 'loclist' ? '[Location List]' : '[Quickfix List]' :
          \ &filetype =~# '\<lsp-hover\>' ? '[LSP Hover Information]' :
          \ empty(l:fname) ? gettext('[No Name]') : l:fname
    endif
  endfunction "}}}

  function! LightlineFiletype() abort "{{{
    return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : '?') : ''
  endfunction "}}}

  function! LightlineFileinfo() abort "{{{
    return IgnoreBuffer() || winwidth(0) <= 75 ? '' :
        \ (strlen(&fileencoding) ? &fileencoding : &encoding) ..
        \ '/' .. &fileformat
  endfunction "}}}

  function! LightlineMode() abort "{{{
    return IsCommandLineWindow() ? 'Cmd' :
        \ &filetype ==# 'help' && !&modifiable ? 'Help' :
        \ &filetype ==# 'qf' ? 'QuickFix' :
        \ (winwidth(0) > 60 ? lightline#mode() : '')
  endfunction "}}}

  function! LightlineTrailingSpaceWarning() abort "{{{
    if IgnoreBuffer()
      return ''
    endif

    let l:space_line = search('\S\zs\s\+$', 'nw')
    return l:space_line != 0 ? 'Space: L' .. l:space_line : ''
  endfunction

  Autocmd BufWritePost * call LightlineTrailingSpaceWarning() | call lightline#update()
  "}}}

  function! LightlineDirectory() abort "{{{
    if &filetype ==# 'netrw'
      return ''
    endif

    let save_shellslash = &shellslash
    set shellslash

    let fname = expand('%:p:h')

    if dein#is_available('gin')
      let scheme = matchstr(fname, '^\w\+://')[:-4]
      if !empty(scheme) && scheme =~# '^gin.*'
        let fname = gin#util#worktree() .. '/' .. gin#util#expand('%:p:h')
      endif
    endif

    let dir = fnamemodify(fname, ':~:.')
    let dir = substitute(dir, '[^/]\zs$', '/', '')

    let &shellslash = save_shellslash
    return pathshorten(dir)
  endfunction "}}}

  function! LightlineGit() abort "{{{
    if dein#is_available('gin')
      " https://deno.land/x/denops_std@v4.1.5/bufname/mod.ts
      let matches = matchlist(bufname(), '^\(\w\+\)://\(\f\+\);\([^#]*\)#\(\f\+\)$')[1:4]
      if !empty(matches)
        let [scheme, expr, params, fragment] = matches
        if !empty(scheme) && scheme =~# '^gin.*'
          let params = split(params, '&')
          let params = filter(params, { _, v -> v =~# '^commitish=' })
          if empty(params)
            let revision = 'INDEX'
          else
            let commitish = params[0][10:]
            let revision = substitute(commitish, '%\(\x\{2}\)', '\=nr2char(str2nr(submatch(1), 16))', 'g')
            let revision = substitute(revision, '^@', 'HEAD', 'g')
          endif

          return revision
        endif
      endif
    endif

    if !exists('t:git_branch')
      let t:git_branch = LightlineBranch()
    endif

    return t:git_branch
  endfunction

  function! LightlineBranch() abort
    if !executable('git')
      return ''
    endif

    silent let is_worktree = trim(system('git rev-parse --is-inside-work-tree'))
    if is_worktree !=# 'true'
      return ''
    endif

    silent let branch = trim(system('git rev-parse --abbrev-ref --short @'))
    if branch !=# 'HEAD'
      return branch
    endif

    silent let commithash = trim(system('git rev-parse --short @'))
    return commithash
  endfunction

  Autocmd BufRead,BufWrite,BufFilePost,DirChanged,FileChangedShell,ShellCmdPost,ShellFilterPost,TabEnter,VimResume *
      \ let t:git_branch = LightlineBranch()
  "}}}
'''
hook_post_source = '''
  call lightline#init()
  call lightline#colorscheme()
  call lightline#update()

  " parteditなどでローカルの値が設定されないのでグローバルに設定
  setglobal statusline=%!lightline#statusline(g:statusline_winid!=#(win_gettype()==#'popup'?win_getid(winnr('#')):win_getid()))
'''

[[plugins]]
repo = 'itchyny/vim-qfedit'

[[plugins]]
repo = 'itchyny/vim-haskell-indent'
on_ft = 'haskell'
hook_source = '''
  let g:haskell_indent_disable_case = 1
'''

[[plugins]]
repo = 'junegunn/fzf'
merged = 0
hook_post_update = 'call fzf#install()'
hook_source = '''
  nnoremap <Leader>b :<C-u>Buffers<CR>
  nnoremap <Leader>e :<C-u>Files<CR>
  nnoremap <Leader>gl :<C-u>GFiles?<CR>
  nnoremap <Leader>mru :<C-u>History<CR>
'''

[[plugins]]
repo = 'junegunn/fzf.vim'
name = 'fzf-plugin'
depends = ['fzf']

[[plugins]]
repo = 'kana/vim-operator-user'

[[plugins]]
repo = 'kana/vim-repeat'

[[plugins]]
repo = 'kana/vim-textobj-user'
hook_source = '''
  function! SameIndent() abort "{{{
    let line = getline('.')
    if empty(line)
      return 0
    endif

    let indent = matchstr(line, '^\s\+')

    call search('^\(' .. indent .. '\|$\)\@!\zs.*$', 'bW')
    let head_pos = getpos('.')

    normal! j
    call search('^\(' .. indent .. '\|$\)\@!\zs.*$', 'eW')
    let tail_pos = getpos('.')

    return ['V', head_pos, tail_pos]
  endfunction "}}}

  function! SameIndent_i() abort "{{{
    let line = getline('.')
    if empty(line)
      return 0
    endif

    let indent = matchstr(line, '^\s\+')

    call search('^\(' .. indent .. '\|$\)\@!\zs.*$', 'bW')
    call search('^' .. indent .. '\zs.*$', 'W')
    let head_pos = getpos('.')

    normal! j
    call search('^\(' .. indent .. '\|$\)\@!\zs.*$', 'eW')
    call search('^' .. indent .. '\zs.*$', 'beW')
    let tail_pos = getpos('.')

    return ['V', head_pos, tail_pos]
  endfunction "}}}
'''
hook_post_source = '''
  call textobj#user#plugin('indent', #{
      \   indent: #{
      \     select-a-function: 'SameIndent',
      \     select-a: 'at',
      \     select-i-function: 'SameIndent_i',
      \     select-i: 'it'
      \   }
      \ })
'''

[[plugins]]
repo = 'lambdalisue/gin.vim'
depends = ['denops']
hook_source = '''
  let g:vimrc#generate_filetypes += [
      \   'gin', 'gin-branch', 'gin-diff', 'gin-edit', 'gin-log', 'gin-status'
      \ ]

  let g:gin_status_default_args = ['++opener=tabnew']
  let g:gin_chaperon_default_args = ['++opener=tabnew']

  function! DiffRevision(commit1, commit2, path)
    " 前提: commit2が新しい
    " commit2 がnullのときworking treeを表示

    if tolower(a:commit1) ==# 'index'
      let commit1 = ''
    else
      let commit1 = a:commit1
    endif
    if tolower(a:commit2) ==# 'index'
      let commit2 = ''
    else
      let commit2 = a:commit2
    endif

    execute 'GinEdit& ++opener=tabnew' commit1 fnamemodify(a:path, ':p')
    diffthis

    if a:commit2 is v:null
      botright vsplit `=a:path`
    else
      execute 'GinEdit& ++opener=botright\ vsplit' commit2 fnamemodify(a:path, ':p')
    endif
    diffthis
  endfunction

  command! -nargs=* -bang -bar G GinStatus<bang> <args>
  command! -nargs=* -bang -bar GB GinBuffer<bang> <args>
  " command! -nargs=* -bang -bar G GinStatus<bang> ++opener=botright\ 15split <args>
  " command! -nargs=1 -complete=file -bar DiffIndex call DiffRevision('INDEX', v:null, <f-args>)
  " command! -nargs=1 -complete=file -bar DiffStage call DiffRevision('HEAD', 'INDEX', <f-args>)
  command! -nargs=1 -complete=file -bar DiffIndex execute 'GinPatch& ++opener=tabnew ++no-head' fnamemodify(<f-args>, ':p') | wincmd l
  command! -nargs=1 -complete=file -bar DiffStage execute 'GinPatch& ++opener=tabnew ++no-worktree' fnamemodify(<f-args>, ':p') | wincmd l

  nnoremap <silent> <Leader>gg :<C-u>G<CR>
  nnoremap <silent> <Leader>gd :<C-u>DiffIndex %<CR>
  nnoremap <silent> <Leader>gs :<C-u>DiffStage %<CR>

  " コミットメッセージ入力時に先頭の行へ移動
  AutocmdFT gitcommit normal! gg

  AutocmdFT gitcommit nnoremap <silent><buffer> <Leader>gd :<C-u>DiffIndex <C-r>=gin#util#worktree()<CR>/<cfile><CR>
  AutocmdFT gitcommit nnoremap <silent><buffer> <Leader>gs :<C-u>DiffStage <C-r>=gin#util#worktree()<CR>/<cfile><CR>

  Autocmd BufEnter gin*://* setlocal nobuflisted
  Autocmd BufEnter ginedit://*;commitish* setlocal nomodifiable
  " Autocmd BufEnter ginedit://*;commitish* call lsp#disable_diagnostics_for_buffer()

  AutocmdFT gitcommit nnoremap <buffer> <Leader>gl :<C-u>GinStatus& ++opener=rightbelow\ split<CR>
  AutocmdFT gin-status nnoremap <buffer> dd <Plug>(gin-action-edit:cached:vsplit):<C-u>diffthis<CR><C-w>p<Plug>(gin-action-edit:local:edit):<C-u>diffthis<CR><C-w>x<C-w>w
  AutocmdFT gin-status nnoremap <buffer> ds <Plug>(gin-action-edit:HEAD:vsplit):<C-u>diffthis<CR><C-w>p<Plug>(gin-action-edit:cached:edit):<C-u>diffthis<CR><C-w>x<C-w>w
'''

[[plugins]]
repo = 'lambdalisue/kensaku.vim'
depends = ['denops']

[[plugins]]
repo = 'lambdalisue/kensaku-command.vim'
depends = ['kensaku']
hook_source = '''
  nnoremap g/ :<C-u>Kensaku<Space>
'''

[[plugins]]
repo = 'lambdalisue/reword.vim'
hook_source = '''
  let g:reword_disable_live = 1

  nnoremap gS :<C-u>%Reword/
  cnoreabbrev <expr> ss Cmdwhen(':', 'ss', 'Reword')
'''

[[plugins]]
repo = 'LumaKernel/ddc-source-file'
depends = ['ddc']

[[plugins]]
repo = 'machakann/vim-vimhelplint'

[[plugins]]
repo = 'mattn/benchvimrc-vim'

[[plugins]]
repo = 'mattn/vim-lsp-settings'
depends = ['lsp']

[[plugins]]
repo = 'mbbill/undotree'
hook_source = '''
  let g:undotree_DiffpanelHeight = 8
  let g:undotree_SetFocusWhenToggle = 1
  let g:undotree_WindowLayout = 2

  nnoremap <Leader>u :<C-u>UndotreeToggle<CR>
'''

[[plugins]]
repo = 'prabirshrestha/vim-lsp'
hook_source = '''
  let g:lsp_completion_documentation_enabled = 0
  let g:lsp_diagnostics_echo_cursor = 1
  let g:lsp_diagnostics_highlights_insert_mode_enabled = 0
  " let g:lsp_diagnostics_signs_enabled = 0
  let g:lsp_diagnostics_signs_insert_mode_enabled = 0
  let g:lsp_diagnostics_virtual_text_enabled = 1
  let g:lsp_diagnostics_virtual_text_align = 'after'
  let g:lsp_inlay_hints_enabled = 1
  let g:lsp_hover_ui = 'preview'
  let g:lsp_preview_float = 0
  let g:lsp_preview_keep_focus = 1
  let g:lsp_untitled_buffer_enabled = 0
  let g:lsp_use_native_client = 0

  let g:lsp_diagnostics_signs_error = #{ text: '!' }
  let g:lsp_diagnostics_signs_warning = #{ text: '*' }
  let g:lsp_diagnostics_signs_hint = #{ text: '.' }
  let g:lsp_diagnostics_signs_information = #{ text: '.' }
  let g:lsp_document_code_action_signs_hint = #{ text: ':' }
  let g:lsp_inlay_hints_mode = #{ normal: ['curline'], insert: [] }

  let g:lsp_diagnostics_signs_priority_map = #{
      \   LspError: 12,
      \   LspWarning: 11
      \ }

  nnoremap <Leader>lh <Plug>(lsp-hover)
  nnoremap <silent> <Leader>ls :<C-u>LspWorkspaceSymbol <C-r>=expand('<lt>cword>')<CR><CR>
  nnoremap <Leader>lt <Plug>(lsp-peek-type-definition)
  nnoremap <Leader>ll <Plug>(lsp-document-diagnostics)
  nnoremap <Leader>lr <Plug>(lsp-rename)
  nnoremap <Leader>lc <Plug>(lsp-code-action)
  xnoremap <silent> <Leader>lc :LspCodeAction<CR>

  " 非同期でカーソルが動くのでスリープを挟む
  nnoremap <silent> <Leader>ld <Plug>(lsp-definition):<C-u>sleep 1m<CR>zvzz
  nnoremap <silent> <Leader>li <Plug>(lsp-implementation):<C-u>sleep 1m<CR>zvzz

  Highlight link LspHintText Question
  Highlight link LspInlayHintsType Comment
  Highlight link LspInlayHintsParameter Comment

  function! s:lsp_highlight_virtualtext() abort
    if g:vimrc#is_nvim
      let hl_question = nvim_get_hl(0, #{ name: 'Question' })
      let hl_question_guifg = printf('#%06X', hl_question.fg)
    else
      " 8.2.3578
      let hl_question = hlget('Question', 1)[0]
      let hl_question_guifg = hl_question.guifg
    endif

    highlight LspErrorVirtualText ctermfg=red ctermbg=61 guifg=red guibg=royalblue4
    highlight LspWarningVirtualText ctermfg=yellow ctermbg=61 guifg=yellow2 guibg=royalblue4
    execute 'highlight LspInformationVirtualText'
        \ printf(
        \   'ctermfg=%s ctermbg=61 guifg=%s guibg=royalblue4',
        \   hl_question.ctermfg, hl_question_guifg
        \ )
    highlight link LspHintVirtualText LspInformationVirtualText
  endfunction
  " :command-keepscript は8.2.3584以降
  execute printf('Autocmd ColorScheme * call %slsp_highlight_virtualtext()', expand('<SID>'))

  " 重いことがあるので一旦無効化
  " Autocmd User lsp_buffer_enabled
  "    \ if &filetype !=# 'vim' |
  "    \   setlocal foldmethod=expr |
  "    \ endif
  " Autocmd User lsp_buffer_enabled setlocal foldexpr=lsp#ui#vim#folding#foldexpr()
  " Autocmd User lsp_buffer_enabled setlocal foldtext=lsp#ui#vim#folding#foldtext()
  Autocmd User lsp_buffer_enabled setlocal signcolumn=yes
  AutocmdFT lsp-hover noremap <buffer><silent> q :<C-u>bwipeout<CR>

  " inlay表示でカーソル位置がずれるので
  " https://github.com/vim/vim/issues/12769
  if !has('patch-9.0.1851')
    Autocmd User lsp_buffer_enabled setlocal nobreakindent breakindentopt= showbreak=NONE
  endif

  if g:vimrc#is_nvim
    Autocmd User lsp_float_opened
        \ if lsp#document_hover_preview_winid() isnot v:null |
        \   call nvim_win_set_option(
        \     lsp#document_hover_preview_winid(),
        \     'winhighlight',
        \     'MatchParen'
        \   ) |
        \ endif
  else
    Autocmd User lsp_float_opened
        \ if lsp#document_hover_preview_winid() isnot v:null |
        \   call setwinvar(
        \     lsp#document_hover_preview_winid(),
        \     '&wincolor',
        \     'MatchParen'
        \   ) |
        \ endif
  endif
'''

[[plugins]]
repo = 'preservim/vim-indent-guides'
hook_source = '''
  let g:indent_guides_auto_colors = 1
  let g:indent_guides_default_mapping = 0
  let g:indent_guides_enable_on_vim_startup = 1
  let g:indent_guides_exclude_filetypes = ['help', 'diff', 'fugitive']
  let g:indent_guides_indent_levels = 15
  let g:indent_guides_start_level = 1

  " Highlight link IndentGuidesOdd Comment
  " Highlight link IndentGuidesEven Folded
'''

[[plugins]]
repo = 'rbtnn/vim-ambiwidth'

[[plugins]]
repo = 'rhysd/conflict-marker.vim'
hook_source = '''
  let g:conflict_marker_enable_mapping = 0
  let g:conflict_marker_highlight_group = ''
  let g:conflict_marker_hooks = #{ on_detected: expand('<SID>') .. 'conflict_marker_on_detected' }

  Highlight link ConflictMarkerBegin Error
  Highlight link ConflictMarkerEnd Error
  Highlight link ConflictMarkerOurs DiffDelete
  Highlight link ConflictMarkerCommonAncestors Error
  Highlight link ConflictMarkerCommonAncestorsHunk Folded
  Highlight link ConflictMarkerTheirs DiffAdd

  function! s:conflict_marker_on_detected() abort
    nnoremap <buffer> ]x <Plug>(conflict-marker-next-hunk)
    nnoremap <buffer> [x <Plug>(conflict-marker-prev-hunk)
  endfunction
'''
hook_post_source = '''
  " 読み込まれてないときがある？
  runtime! plugin/conflict_marker.vim
  autocmd ConflictMarkerDetect BufEnter * doautocmd ConflictMarkerDetect BufRead
'''

[[plugins]]
repo = 'rhysd/vim-operator-surround'
depends = ['operator-user']
hook_source = '''
  nnoremap s <Plug>(operator-surround-append)
  xnoremap s <Plug>(operator-surround-append)
  nnoremap ds <Plug>(operator-surround-delete)a
  nnoremap dsi <Plug>(operator-surround-delete)i
  nnoremap cs <Plug>(operator-surround-replace)a
  nnoremap csi <Plug>(operator-surround-replace)i
'''

[[plugins]]
repo = 'rhysd/vim-textobj-word-column'
depends = ['textobj-user']

[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'Shougo/ddc.vim'
depends = ['denops']
hook_post_source = '''
  " if !exists('#denops_plugin_internal')
  "   " denopsがサポートされてない
  "   return
  " endif

  call ddc#custom#set_global({})
  call ddc#custom#patch_global('sources', ['vim-lsp', 'around', 'other-window'])

  let g:ddc_display_ui = dein#is_available(['pum', 'ddc-ui-pum']) ? 'pum' : 'native'
  call ddc#custom#patch_global('ui', 'none')
  " call ddc#custom#patch_global('ui', g:ddc_display_ui)

  call ddc#custom#patch_filetype('vim', 'sources', ['necovim', 'around', 'other-window'])
  call ddc#custom#patch_filetype('vim', 'sourceParams', #{
      \   other-window: #{
      \     include_filetypes: ['help']
      \   }
      \ })

  call ddc#custom#patch_global('sourceOptions', #{
      \   _: #{
      \     dup: 'keep',
      \     matchers: ['matcher_head'],
      \     sorters: ['sorter_rank'],
      \     ignoreCase: v:true,
      \     minAutoCompleteLength: 1,
      \     timeout: 5000
      \   },
      \   around: #{
      \     mark: 'A',
      \     minAutoCompleteLength: 2
      \   },
      \   vim-lsp: #{
      \     mark: 'L',
      \     forceCompletionPattern: '(::|->|\.)',
      \     minAutoCompleteLength: 0,
      \     sorters: ['sorter_rank', 'sorter_ascii']
      \   },
      \   file: #{
      \     sorters: ['sorter_ascii'],
      \     forceCompletionPattern: '/',
      \     isVolatile: v:true
      \   },
      \   necovim: #{
      \     mark: 'vim',
      \     sorters: ['sorter_rank', 'sorter_ascii'],
      \     minAutoCompleteLength: 0
      \   },
      \   neosnippet: #{ mark: 'snip' },
      \   other-window: #{
      \     mark: 'win',
      \     minAutoCompleteLength: 2
      \   }
      \ })
  call ddc#custom#patch_global('sourceParams', #{
      \   around: #{
      \     maxSize: 500
      \   },
      \   file: #{
      \     displayCwd: 'c',
      \     displayBuf: 'b',
      \     filenameChars: '\-@.[:alnum:]_~'
      \   }
      \ })

  if dein#is_available('skkeleton')
    function! s:skkeleton_enable()
      if !exists('b:ddc_options')
        " skkeleton有効時の設定が入ることがあるので初回だけ
        let b:ddc_options = ddc#custom#get_buffer()

        " preview 外すと機能しなくなるので一旦無効化
        " let b:save_cot = &completeopt
        " set completeopt-=preview
      endif

      call ddc#custom#set_buffer(#{
          \   ui: g:ddc_display_ui,
          \   sources: ['skkeleton', 'around'],
          \   keywordPattern: '[ぁ-ゖァ-ヶー]+',
          \   sourceOptions: #{
          \     _: #{
          \       sorters: [],
          \       matchers: [],
          \     }
          \   }
          \ })
    endfunction
    execute printf('Autocmd User skkeleton-enable-pre call %sskkeleton_enable()', expand('<SID>'))

    function! s:skkeleton_disable()
      call ddc#custom#set_buffer(b:ddc_options)
      " let &completeopt = b:save_cot
    endfunction
    execute printf('Autocmd User skkeleton-disable-pre call %sskkeleton_disable()', expand('<SID>'))

    call ddc#custom#patch_global('sourceOptions', #{
        \   skkeleton: #{
        \     mark: 'SKK',
        \     matchers: ['skkeleton'],
        \     sorters: [],
        \     converters: [],
        \     minAutoCompleteLength: 1,
        \     isVolatile: v:true
        \   }
        \ })
  endif

  call ddc#enable(#{ context_filetype: 'context_filetype' })

  inoremap <silent><expr> <C-n> pumvisible() ? '<Plug>(vimrc_complete-next)' : '<Plug>(vimrc_complete-manual_complete)'
  inoremap <silent><expr> <C-p> pumvisible() ? '<Plug>(vimrc_complete-prev)' : '<Plug>(vimrc_complete-manual_complete)'
  inoremap <silent><expr> <Plug>(vimrc_complete-manual_complete) ddc#map#complete(g:ddc_display_ui)
  inoremap <silent><expr> <Plug>(vimrc_complete-file)
      \ ddc#map#manual_complete(#{
      \   sources: ['file'], ui: g:ddc_display_ui
      \ })
  inoremap <C-l> <Nop>
  inoremap <silent><expr> <C-l>s
      \ ddc#map#manual_complete(#{
      \   sources: ['neosnippet'], ui: g:ddc_display_ui
      \ })
  " imap <C-Space> <C-n>

  Autocmd InsertLeave * if !IsCommandLineWindow() | pclose | endif
'''

[[plugins]]
repo = 'Shougo/ddc-filter-matcher_head'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/ddc-filter-sorter_rank'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/ddc-source-around'
depends = ['ddc']

# [[plugins]]
# repo = 'Shougo/ddc-source-line'
# depends = ['ddc']

[[plugins]]
repo = 'Shougo/ddc-ui-native'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/ddc-ui-none'
depends = ['ddc']

# [[plugins]]
# repo = 'Shougo/ddc-ui-pum'
# depends = ['ddc', 'pum']

[[plugins]]
repo = 'Shougo/neco-vim'
depends = ['ddc']

[[plugins]]
repo = 'Shougo/neosnippet.vim'
depends = ['neosnippet-snippets', 'ddc']
hook_source = '''
  let g:neosnippet#disable_select_mode_mappings = 0
  let g:neosnippet#enable_auto_clear_markers = 0
  " let g:neosnippet#enable_completed_snippet = 1
  " let g:neosnippet#enable_complete_done = 1

  snoremap <expr> <Tab> neosnippet#jumpable() ?
     \ '<Esc>a<Plug>(neosnippet_jump)' : '<Plug>(vimrc_tab)'
  inoremap <expr> <Tab>
      \ pumvisible() ?
      \   neosnippet#expandable_or_jumpable() ? '<Plug>(neosnippet_expand_or_jump)' : '' :
      \   neosnippet#jumpable() ? '<Plug>(neosnippet_jump)' : '<Plug>(vimrc_tab)'
  " neosnippet がソースになくても同名の候補でスニペットが展開されるのでv:completed_itemを見て展開しないようにする
  inoremap <expr> <CR>
      \ pumvisible() ?
      \   get(v:completed_item, 'menu', '') =~# '^snip\>' && neosnippet#expandable() ?
      \     '<Plug>(neosnippet_expand)' : '<Plug>(vimrc_complete-confirm)' : '<Plug>(vimrc_cr)'
  snoremap <silent> <CR> <C-r>"a<BS><C-r>"
  snoremap <silent> <BS> <C-r>_a<BS>

  Autocmd InsertLeave * NeoSnippetClearMarkers
  " Autocmd User lsp_complete_done call neosnippet#complete_done()

  if has('conceal')
    set conceallevel=2 concealcursor=iv
  endif
'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'
merged = 0
hook_source = '''
  let g:neosnippet#snippets_directory = g:dein#plugin.path .. '/neosnippet'
'''

# [[plugins]]
# repo = 'Shougo/pum.vim'
# hook_source = '''
#   " WIP
#   inoremap <expr> <Plug>(vimrc_complete-next) pum#visible() ? pum#map#insert_relative(1, 'loop') : ''
#   inoremap <expr> <Plug>(vimrc_complete-prev) pum#visible() ? pum#map#insert_relative(-1, 'loop') : ''
# '''
# hook_post_source = '''
#   " WIP
#   call pum#set_option(#{
#       \ })
# '''

[[plugins]]
repo = 'shun/ddc-source-vim-lsp'
depends = ['ddc', 'lsp']

[[plugins]]
repo = 'skk-dev/dict'
name = 'skk-dict'
merged = 0
hook_source = '''
  let s:skk_dict_dir = g:dein#plugin.path
'''

[[plugins]]
repo = 'thinca/vim-ft-help_fold'
name = 'help-fold'

[[plugins]]
repo = 'thinca/vim-partedit'
hook_source = '''
  let g:partedit#opener = 'split'

  function! OpenContext() abort
    " ex. {'filetype': 'vim', 'range': [[1114, 1], [1128, 90]]}
    let context = context_filetype#get()
    let ft = context.filetype
    let lines = [context.range[0][0], context.range[1][0]]

    call partedit#start(lines[0], lines[1], #{ filetype: ft })
    nnoremap <silent><buffer> <Leader>p :<C-u>ParteditEnd<CR><C-w>c

    if dein#is_available('ddc')
      call ddc#custom#patch_buffer('specialBufferCompletion', v:true)
    endif
  endfunction

  Autocmd BufReadPost dein.toml,dein/*.toml let b:partedit_filetype = 'vim'
  Autocmd BufReadPost dein.toml,dein/*.toml let b:partedit_prefix = '\s*'
  AutocmdFT markdown,toml nnoremap <silent><buffer> <Leader>p :<C-u>call OpenContext()<CR>
'''

[[plugins]]
repo = 'thinca/vim-prettyprint'

[[plugins]]
repo = 'thomasfaingnaert/vim-lsp-snippets'
depends = ['lsp']

[[plugins]]
repo = 'thomasfaingnaert/vim-lsp-neosnippet'
depends = ['lsp', 'neosnippet']

[[plugins]]
repo = 'tyru/caw.vim'
depends = ['operator-user', 'repeat']
hook_source = '''
  let g:caw_dollarpos_sp_left = ' '
  let g:caw_hatpos_align = 1
  let g:caw_hatpos_skip_blank_line = 1
  " let g:caw_no_default_keymappings = 1
  let g:caw_operator_keymappings = 1

  AutocmdFT haskell let b:caw_wrap_oneline_comment = ['{-', '-}']
  AutocmdFT haskell let b:caw_wrap_multiline_comment = #{ left: '{-', right: '-}', top: '-', bottom: '-' }

  " nnoremap <silent><expr> <Leader>cc '<C-c>V' .. (v:count <= 1 ? 'V' : v:count - 1 .. 'gj') .. '<Plug>(caw:hatpos:toggle)'
  nnoremap <Leader>cc <Plug>(caw:hatpos:toggle)
  xnoremap <Leader>cc <Plug>(caw:hatpos:toggle)
  noremap <silent> <Leader>ct :normal 1 cc<CR>
  sunmap <Leader>ct
  ounmap <Leader>ct

  nnoremap <Leader>cu <Plug>(caw:hatpos:uncomment)
  xnoremap <Leader>cu <Plug>(caw:hatpos:uncomment)
  nnoremap <Leader>cd <Plug>(caw:hatpos:toggle:operator)
  nnoremap <Leader>ca <Plug>(caw:dollarpos:toggle)
  nnoremap <Leader>cw <Plug>(caw:wrap:toggle:operator)
  xnoremap <Leader>cw <Plug>(caw:wrap:toggle)
  nnoremap <Leader>co <Plug>(caw:jump:comment-next)
  nnoremap <Leader>cO <Plug>(caw:jump:comment-prev)
'''

[[plugins]]
repo = 'tyru/operator-camelize.vim'
hook_source = '''
nnoremap sc <Plug>(operator-camelize-toggle)
'''

[[plugins]]
repo = 'vim-denops/denops.vim'
if = 'executable("deno")'

[[plugins]]
repo = 'vim-jp/vimdoc-ja'

[[plugins]]
repo = 'vim-skk/skkeleton'
depends = ['denops']
hook_source = '''
  noremap! ,, <Plug>(skkeleton-enable)

  function! s:skk_init()
    call skkeleton#config(#{
        \   eggLikeNewline: v:true,
        \   globalDictionaries: [s:skk_dict_dir .. '/SKK-JISYO.L'],
        \   keepState: v:true,
        \   markerHenkan: '',
        \   markerHenkanSelect: ''
        \ })
    call skkeleton#register_kanatable('rom', #{
        \   jk: 'escape'
        \ })
    call skkeleton#register_keymap('input', ';', 'henkanPoint')

    call remove(g:skkeleton#mapped_keys, index(g:skkeleton#mapped_keys, '<Down>'))
    call remove(g:skkeleton#mapped_keys, index(g:skkeleton#mapped_keys, '<Up>'))
  endfunction
  execute printf('Autocmd User skkeleton-initialize-pre call %sskk_init()', expand('<SID>'))
'''

[[plugins]]
repo = 'yasunori-kirin0418/lightline_skk.vim'
depends = ['lightline', 'skkeleton']
hook_post_source = '''
  call lightline_skk#option('display', #{
      \   hiragana: 'あ',
      \   katakana: 'ア',
      \   hankaku_katakana: ' ｱ',
      \   zenkaku_alphabet: 'Ａ',
      \   alphabet: '',
      \   abbrev: 'ab'
      \ })
'''

[[plugins]]
repo = 'yuki-yano/fuzzy-motion.vim'
depends = ['denops']
hook_source = '''
  if dein#is_available('kensaku')
    let g:fuzzy_motion_matchers = ['fzf', 'kensaku']
  endif

  nnoremap <silent> <Leader>f :<C-u>FuzzyMotion<CR>
'''


[[plugins]]
repo = 'equalsraf/neovim-gui-shim'
if = 'g:vimrc#is_nvim'

[[plugins]]
repo = 'kevinhwang91/nvim-bqf'
if = 'g:vimrc#is_nvim'
hook_source = '''
  " Highlight link BqfPreviewBorder Pmenu
  Highlight BqfPreviewFloat ctermbg=18 guibg=midnightblue
'''
lua_post_source = '''
  require('bqf').setup({
    func_map = {
      pscrollup = '<C-u>',
      pscrolldown = '<C-d>',
    },
    magic_window = false,
    preview = {
      border_chars = {'', '', '─', '─', '─', '─', '─', '─', '█'},
      show_title = true
    },
    wrap = true
  })
'''

[[plugins]]
repo = 'bfrg/vim-qf-preview'
if = '!g:vimrc#is_nvim'
hook_source = '''
  let g:qfpreview = #{
      \   close: 'q',
      \   halfpageup: "\<C-u>",
      \   harlpagedown: "\<C-d>",
      \   next: 'n',
      \   number: 1,
      \   offset: 2,
      \   previous: 'p',
      \ }

  Highlight QfPreview ctermbg=18 guibg=midnightblue

  AutocmdFT qf nnoremap <buffer> p <Plug>(qf-preview-open)
  AutocmdFT qf execute "normal! \<Plug>(qf-preview-open)"
  " AutocmdFT qf Autocmd CursorMoved <buffer> execute "normal! \<Plug>(qf-preview-open)"
'''

[[plugins]]
repo = 'phaazon/hop.nvim'
if = 'g:vimrc#is_nvim'
hook_source = '''
  nnoremap <Leader><Leader>w :<C-u>HopWord<CR>
  nnoremap <Leader><Leader>j :<C-u>HopLineStart<CR>
  nnoremap <Leader><Leader>f :<C-u>HopChar1<CR>
  nnoremap <Leader><Leader>n :<C-u>call v:lua.require('hop').hint_patterns({}, @/)<CR>
'''
lua_post_source = '''
  require('hop').setup({
    keys = 'fjdksla;ghrueiwoqptyvmc,x.z/bn'
  })
'''

[[plugins]]
repo = 'monkoose/vim9-stargate'
if = '!g:vimrc#is_nvim'
hook_source = '''
  let g:stargate_chars = 'fjdksla;ghrueiwoqptyvmc,x.z/bn'

  nnoremap <Leader><Leader>w <Cmd>call stargate#OKvim('\<')<CR>
  nnoremap <Leader><Leader>j <Cmd>call stargate#OKvim('\_^\s*\zs\S')<CR>
  nnoremap <Leader><Leader>f <Cmd>call stargate#OKvim(1)<CR>
  nnoremap <Leader><Leader>n <Cmd>call stargate#OKvim(@/)<CR>
'''

[[plugins]]
repo = 'mattn/vimtweak'
if = '!g:vimrc#is_nvim && g:vimrc#is_windows && g:vimrc#is_gui'

